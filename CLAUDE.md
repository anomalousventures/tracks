# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Tracks is a Rails-inspired web framework for Go that generates idiomatic, production-ready applications. It's a CLI tool built with Cobra that includes an interactive TUI (Bubble Tea) for code generation. The project uses a monorepo structure with Go code for the CLI and a Docusaurus website for documentation.

## Development Commands

### Setup

```bash
# Install all dependencies (Go + Node.js/pnpm)
pnpm install
go mod download

# View all available commands
make help
```

### Testing

```bash
# Run unit tests
make test

# Run tests with coverage report
make test-coverage

# Run integration tests
make test-integration

# Run all tests
make test-all
```

### Building

```bash
# Build tracks CLI
make build

# Build tracks-mcp server
make build-mcp

# Build all binaries
make build-all

# Install to $GOPATH/bin
make install
```

### Linting

```bash
# Lint markdown files
make lint-md

# Auto-fix markdown issues
make lint-md-fix

# Lint Go code
make lint-go

# Run all linters
make lint
```

### Website (Docusaurus)

```bash
# Start dev server with hot reload
make website-dev

# Build for production
make website-build

# Serve built site locally
make website-serve

# Deploy to GitHub Pages
make website-deploy
```

### Development

```bash
# Run tracks CLI in development
make dev

# Clean build artifacts
make clean

# Update dependencies
make deps
```

## Architecture

### Monorepo Structure

- `/cmd/tracks/` - Main CLI tool with TUI
- `/cmd/tracks-mcp/` - MCP server for AI-powered development
- `/internal/` - Private Go packages (generator, TUI, MCP)
- `/pkg/` - Public Go packages
- `/website/` - Docusaurus documentation site
- `/docs/prd/` - Product requirements and design docs
- `/examples/` - Example applications

### Generated Application Architecture

Tracks generates applications with layered architecture:

**Request Flow:** HTTP Request → Handler → Service → Repository → Database

**Key Principles:**

1. **Dependency Injection** - Services receive dependencies via constructors for testability
2. **Interface-Based Design** - All external dependencies use interfaces
3. **Context Propagation** - Always pass `context.Context` as first parameter
4. **Explicit Error Handling** - Errors are wrapped with context using `fmt.Errorf("...: %w", err)`
5. **Type-Safe SQL** - Uses SQLC to generate Go code from SQL queries
6. **Type-Safe Templates** - Uses templ for compile-time HTML safety

### Layer Responsibilities

- **Handlers** (`internal/handlers/`) - HTTP request/response, validation, call services
- **Services** (`internal/services/`) - Business logic, independent of HTTP
- **Repositories** (`internal/repositories/`) - Data access only, generated by SQLC
- **Middleware** (`internal/middleware/`) - Single-responsibility composable functions
- **Templates** (`internal/templates/`) - templ components compiled to Go

## Code Generation

Tracks provides interactive TUI generators that produce idiomatic Go code:

```bash
# Launch interactive TUI
tracks

# Generate complete CRUD resource
tracks generate resource post title:string content:text author:relation published:bool

# Generate individual components
tracks generate handler webhook
tracks generate service notification
tracks generate repository comment
tracks generate migration add_published_to_posts
```

### Generation Principles

1. Generated code should look hand-written by an experienced Go developer
2. No magic or reflection - everything is explicit
3. DTOs are generated with field-level validation rules
4. Services use dependency injection for easy testing
5. Route helpers are auto-generated for type-safe URLs
6. Tests with mocks are generated by default

## Coding Standards

### Go Code Style

- Follow standard Go conventions (gofmt, golint)
- Comments explain WHY, never WHAT
- Keep functions small and focused
- Use interfaces for dependency injection
- Handle errors explicitly, never ignore them
- Use table-driven tests with `t.Run()` for subtests

### Error Handling

```go
// GOOD: Wrap errors with context
if err != nil {
    return fmt.Errorf("failed to create user: %w", err)
}

// BAD: Generic error
if err != nil {
    return errors.New("error occurred")
}
```

### Testing

- Write table-driven tests when appropriate
- Use mocks for external dependencies
- Test edge cases and error paths
- Aim for >80% coverage on new code

## Configuration

Uses hierarchical configuration (lowest to highest priority):

1. Default values in code
2. Configuration file (`tracks.yaml`)
3. Environment variables (prefixed with `APP_`)

## Database

- **Default:** LibSQL/Turso (requires CGO)
- **Alternatives:** SQLite (requires CGO), PostgreSQL (no CGO)
- **Migrations:** Goose with timestamp prefixes
- **Queries:** Written in SQL, processed by SQLC for type safety
- **IDs:** UUIDv7 (timestamp-ordered)

## Release Process

```bash
# Generate changelog
make changelog

# Create and push release tag
make release VERSION=v0.1.0

# Test release locally
make release-dry-run
```

Releases use:

- **Conventional Commits** for commit messages
- **GoReleaser** for building cross-platform binaries
- **git-chglog** for changelog generation
- **GitHub Actions** for automated releases

## Commit Message Format

Follow [Conventional Commits](https://www.conventionalcommits.org/):

```text
<type>(<scope>): <description>

[optional body]

[optional footer]
```

**Types:** `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, `perf`

**IMPORTANT:** Commit messages should be TERSE. Keep descriptions concise and focused.

## Pull Request Process

- PR titles must use Conventional Commits format (used for squash merge commit)
- Follow the template in `.github/pull_request_template.md`
- Ensure tests pass locally and linting passes (`make lint`)
- Keep PRs small and focused on a single change
- PR title becomes the commit message in main branch (squash merge)

## Important Notes

- **Go Version:** Requires Go 1.25+
- **Node Version:** Requires Node.js 24+ and pnpm 10+
- **CGO Requirements:** LibSQL and SQLite require `CGO_ENABLED=1` and build tools (gcc/xcode)
- **PostgreSQL:** Can build static binaries with `CGO_ENABLED=0`
- **PR Process:** We use squash merging, so PR title becomes the commit message

## Documentation

- **PRD Docs:** `/docs/prd/` contains detailed product requirements
- **Website Docs:** `/website/docs/` contains user-facing documentation
- **API Docs:** Use godoc comments for exported functions
- **Architecture:** See `/docs/prd/1_core_architecture.md` for details
