# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## ‚ö†Ô∏è REQUIRED: Pre-Commit Validation

**Before making ANY commit, you MUST:**

1. **Run `make generate-mocks`** - Generate test mocks from interfaces
2. **Run `make lint`** - All linters must pass with zero errors
3. **Run `make test`** - All tests must pass with zero failures
4. **Remediate any errors** - Fix all issues found by linting and testing

**Failure to complete these steps successfully means the code is NOT ready to commit.**

**Note:** Generated mocks must be committed to the repository. The lint job checks that mocks are up-to-date.

## Quick Start

**For development setup, coding standards, and contribution guidelines, see [CONTRIBUTING.md](./CONTRIBUTING.md).**

This file contains Claude-specific context about the project architecture, common workflows, and patterns.

## Project Overview

Tracks is a code-generating web framework for Go that produces idiomatic, production-ready applications. It's a CLI tool built with Cobra that includes an interactive TUI (Bubble Tea) for code generation.

**Current Status:** Phase 0 (Foundation) - building the CLI tool and project scaffolding.

**Key Technologies:**

- CLI: Cobra + Bubble Tea (TUI)
- Generated Apps: Chi, templ, SQLC, HTMX
- Monorepo: Go + Docusaurus

## Quick Command Reference

```bash
make help              # Show all available commands
make test              # Run unit tests
make lint              # Run all linters
make build             # Build tracks CLI
make website-dev       # Start Docusaurus dev server
```

See [CONTRIBUTING.md](./CONTRIBUTING.md) for complete development workflow.

## Architecture

### Monorepo Structure

```text
tracks/
‚îú‚îÄ‚îÄ cmd/
‚îÇ   ‚îú‚îÄ‚îÄ tracks/        # Main CLI tool
‚îÇ   ‚îî‚îÄ‚îÄ tracks-mcp/    # MCP server
‚îú‚îÄ‚îÄ internal/
‚îÇ   ‚îú‚îÄ‚îÄ cli/           # CLI commands and UI
‚îÇ   ‚îú‚îÄ‚îÄ generator/     # Code generators
‚îÇ   ‚îî‚îÄ‚îÄ templates/     # Embedded templates
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ prd/           # Product requirements (detailed specs)
‚îÇ   ‚îî‚îÄ‚îÄ roadmap/       # Phase and epic breakdown
‚îú‚îÄ‚îÄ website/           # Docusaurus documentation
‚îî‚îÄ‚îÄ examples/          # Example generated apps
```

### Generated Application Architecture

Tracks generates applications with clean layered architecture:

**Request Flow:** HTTP Request ‚Üí Handler ‚Üí Service ‚Üí Repository ‚Üí Database

**Key Principles:**

1. **Dependency Injection** - Services receive dependencies via constructors for testability
2. **Interface-Based Design** - All external dependencies use interfaces
3. **Context Propagation** - Always pass `context.Context` as first parameter
4. **Explicit Error Handling** - Errors are wrapped with context using `fmt.Errorf("...: %w", err)`
5. **Type-Safe SQL** - Uses SQLC to generate Go code from SQL queries
6. **Type-Safe Templates** - Uses templ for compile-time HTML safety

**Layer Responsibilities:**

- **Handlers** (`internal/handlers/`) - HTTP request/response, validation, call services
- **Services** (`internal/services/`) - Business logic, independent of HTTP
- **Repositories** (`internal/repositories/`) - Data access only, generated by SQLC
- **Middleware** (`internal/middleware/`) - Single-responsibility composable functions
- **Templates** (`internal/templates/`) - templ components compiled to Go

### CLI Tool Architecture (tracks itself)

The tracks CLI tool follows the same clean architecture principles as generated applications, with some CLI-specific patterns.

**Core Principles:**

1. **Dependency Injection** - Commands receive dependencies via constructors
2. **Interface-First** - Interfaces defined in consumer packages (`internal/cli/interfaces/`)
3. **Context Propagation** - Logger and request-scoped values passed via context
4. **Separation of Concerns** - Clear boundaries between commands, validation, generation

**Dual-Output Strategy:**

- **Renderer** (stdout) - User-facing output using Lip Gloss/Bubbles (human-friendly)
- **Logger** (stderr) - Developer/debug logging using zerolog (controlled by `TRACKS_LOG_LEVEL`)

This separation keeps user experience clean while enabling debugging.

**Package Structure:**

```text
internal/cli/
‚îú‚îÄ‚îÄ commands/          # Command implementations (NewCommand, VersionCommand, etc.)
‚îú‚îÄ‚îÄ interfaces/        # Interfaces consumed by CLI (Validator, ProjectGenerator)
‚îú‚îÄ‚îÄ renderer/          # Output formatting (Console, JSON, TUI)
‚îú‚îÄ‚îÄ ui/                # Mode detection, theming
‚îú‚îÄ‚îÄ logger.go          # zerolog setup for developer logging
‚îî‚îÄ‚îÄ root.go            # Root command setup, DI wiring
```

**Key Files:**

- `internal/cli/commands/*.go` - Individual command implementations
- `internal/cli/interfaces/*.go` - Interfaces for external dependencies
- `internal/cli/ui/mode.go` - Mode detection (TTY, CI, flags)
- `internal/cli/ui/theme.go` - Lip Gloss styles
- `internal/cli/renderer/` - Renderer implementations (Console, JSON, TUI)
- `internal/cli/logger.go` - zerolog configuration

## Code Generation Principles

When implementing or reviewing generators:

1. Generated code should look hand-written by an experienced Go developer
2. No magic or reflection - everything is explicit
3. DTOs are generated with field-level validation rules
4. Services use dependency injection for easy testing
5. Route helpers are auto-generated for type-safe URLs
6. Tests with mocks are generated by default

## Important Patterns and Gotchas

### Go 1.25+ Tool Directive

All development tools (golangci-lint, air, etc.) use the `go tool <name>` pattern:

```bash
go tool golangci-lint run
go tool air -c .air.toml
```

This is the modern Go 1.25+ pattern where tools are declared in `go.mod` with the `tool` directive and invoked via `go tool <name>`. Never suggest global installations.

### CLI Output vs Generated App Logging

- **CLI Tool (tracks)** - Uses Renderer pattern for human-friendly output (Lip Gloss, Bubbles)
- **Generated Apps** - Use zerolog for structured JSON logging in production

These are two different contexts with different needs. Don't confuse them.

### Cross-Platform Path Handling

Always use `filepath` package for path operations:

```go
// GOOD: Cross-platform
projectDir := filepath.Join(baseDir, projectName)
templatePath := filepath.FromSlash("internal/templates/project")

// BAD: Platform-specific
projectDir := baseDir + "/" + projectName
```

### Error Wrapping

Always wrap errors with context using `%w`:

```go
// GOOD: Preserves error chain
if err != nil {
    return fmt.Errorf("failed to create user: %w", err)
}

// BAD: Loses error chain
if err != nil {
    return errors.New("error occurred")
}
```

## Database Context

- **Default:** LibSQL/Turso (requires CGO, gcc/musl-dev on Alpine)
- **Alternatives:** SQLite (requires CGO), PostgreSQL (no CGO, static builds)
- **Migrations:** Goose with timestamp prefixes
- **Queries:** Written in SQL, processed by SQLC for type safety
- **IDs:** UUIDv7 (timestamp-ordered UUIDs)

## Documentation Structure

- **`/docs/prd/`** - Detailed product requirements (the "what" and "why")
- **`/docs/roadmap/`** - Phase breakdown and epic planning (the "when" and "how")
- **`/website/docs/`** - User-facing documentation (guides, tutorials)
- **`CONTRIBUTING.md`** - Development setup and standards (start here for dev work)

## Configuration

Hierarchical configuration (lowest to highest priority):

1. Default values in code
2. Configuration file (`tracks.yaml`)
3. Environment variables (prefixed with `APP_`)

## Development Workflow Tips

### Working on CLI Features

1. Read the relevant epic in `/docs/roadmap/phases/` to understand the plan
2. Check GitHub issues for task breakdown and acceptance criteria
3. Run `make build && ./bin/tracks <command>` to test changes
4. Use `make lint` before committing

### Working on Generators

1. Check `/docs/prd/` for detailed specs on what should be generated
2. Templates live in `internal/templates/` and are embedded via `embed.go`
3. Test by generating actual projects and verifying they build/run
4. Generated code should pass `go vet` and `golangci-lint`

### Working on Documentation

- Markdown files must pass `make lint-md`
- Roadmap docs live in `/docs/roadmap/`
- PRD docs live in `/docs/prd/`
- User docs live in `/website/docs/` (Docusaurus)

## Commit and PR Guidelines

**See [CONTRIBUTING.md](./CONTRIBUTING.md) for detailed PR process.**

Quick reminders:

- PR titles use Conventional Commits format (becomes squash merge commit message)
- Follow the PR template in `.github/pull_request_template.md`
- Keep commit messages TERSE and focused
- Write PR descriptions naturally, avoid AI slop
- Use `make lint` before committing

## Environment Requirements

- **Go:** 1.25+ required
- **Node.js:** 24+ with pnpm 10+ (for website)
- **CGO:** Required for LibSQL/SQLite (needs gcc on Linux, xcode on macOS)
- **Git:** For version control and release process

## Release Process

```bash
make changelog              # Generate changelog from commits
make release-prep           # Verify prerequisites and show next steps
make release-tag VERSION=v0.1.0 # Create and push release tag
```

See [docs/RELEASE_PROCESS.md](./docs/RELEASE_PROCESS.md) for complete release workflow.

---

## üö® MANDATORY: Always Validate Before Committing

**This is a critical requirement that cannot be skipped:**

Before creating any commit, you must SUCCESSFULLY complete:

1. **`make lint`** - Fix ALL linting errors
2. **`make test`** - Fix ALL test failures

If either command fails, you MUST remediate the errors before proceeding. Code that fails linting or testing is NOT ready to commit.

---

**Note:** This file focuses on Claude-specific context. For development setup, coding standards, and contribution guidelines, see [CONTRIBUTING.md](./CONTRIBUTING.md).
