# Epic 1.5: Templ-UI Integration

[← Back to Phase 1](../1-core-web.md) | [← Epic 1.4](./1.4-web-build-pipeline.md)

**Decision:** [ADR-009: Templ-UI for UI Components](../../../adr/009-templui-for-ui-components.md)

## Overview

Integrate templ-ui as the core UI component library for generated applications. This epic implements automatic installation of templ-ui during project generation, installs a comprehensive starter component set (forms, layout, feedback), and provides CLI commands for adding/listing components. Users own the copied component code and can customize freely, following the shadcn/ui philosophy of "copy code, own components."

## Goals

- Templui CLI installed in generated projects
- Automatic `templui init` during `tracks new`
- Full starter component set installed by default
- `tracks ui add <component>` command
- `tracks ui list` command
- Components in `internal/http/views/components/ui/`
- Tailwind config updated to include templ-ui styles
- Component customization documented
- Example pages using templ-ui components

## Scope

### In Scope

- Add `github.com/templui/templui` to tool directive
- Run `templui init` during project generation
- Install starter component set automatically
- Create `tracks ui add` subcommand
- Create `tracks ui list` subcommand
- Configure templui.yaml
- Update Tailwind config for templ-ui
- Create example pages using components
- Document component usage
- Document customization workflow

### Out of Scope

- Custom component development (users do this)
- Complex form validation libraries (future)
- Data tables with server-side pagination (future)
- Chart/graph components (future)
- Rich text editors (future)
- Component testing framework (future)

## Task Breakdown

The following tasks will become GitHub issues, ordered by dependency:

### Phase 1: Templui Foundation (Tasks 1-10)

1. **Add templui to tool directive in generated go.mod**
   - Add `github.com/templui/templui`
   - Document version constraints

2. **Create templui.yaml configuration template**
   - Configure component output directory
   - Set templ-ui styles path
   - Document configuration options

3. **Run `templui init` during `tracks new`**
   - After project structure created
   - Before component installation
   - Verify initialization succeeds

4. **Install starter component set automatically**
   - Forms: button, input, textarea, label, checkbox, radio, select
   - Layout: card, modal, dialog, sidebar, tabs, accordion, sheet
   - Feedback: alert, toast, progress, spinner, skeleton
   - Document installed components

5. **Verify components copied to correct location**
   - `internal/http/views/components/ui/`
   - Check file structure
   - Verify templ syntax

6. **Update Tailwind config for templ-ui styles**
   - Add templ-ui CSS imports
   - Configure content paths to scan components
   - Document Tailwind integration

7. **Create ProjectGenerator integration**
   - Add `installTemplUI()` step
   - Handle errors gracefully
   - Log installation progress

8. **Test templui initialization**
   - Verify init creates config file
   - Verify components installed
   - Check for errors

9. **Document templui integration in README**
   - Explain component ownership model
   - Show directory structure
   - Link to templ-ui docs

10. **Create troubleshooting guide**
    - Common templui installation issues
    - Component conflicts
    - Update procedures

### Phase 2: tracks ui Commands (Tasks 11-25)

11. **Create `tracks ui` subcommand structure**
    - Parent command for UI operations
    - Help text and examples
    - Subcommand routing

12. **Create `tracks ui add` subcommand**
    - Add single component
    - Syntax: `tracks ui add <component>`
    - Delegate to templui CLI

13. **Implement component name validation**
    - Check component exists in templ-ui
    - Provide helpful error messages
    - Suggest similar component names

14. **Add progress output for component installation**
    - Show component being added
    - Show success/failure
    - Use Renderer for output

15. **Create `tracks ui list` subcommand**
    - List all available components
    - Show installed vs available
    - Group by category (forms, layout, feedback)

16. **Format component list output**
    - Use Renderer for tables
    - Color-code installed components
    - Show component descriptions

17. **Add `tracks ui add <component> --force` flag**
    - Overwrite existing component
    - Prompt for confirmation
    - Document force flag

18. **Create `tracks ui update <component>` subcommand**
    - Update specific component from upstream
    - Show diff before updating
    - Document update process

19. **Add `tracks ui remove <component>` subcommand**
    - Remove component from project
    - Prompt for confirmation
    - Clean up related files

20. **Create `tracks ui search <query>` subcommand**
    - Search available components
    - Filter by keyword
    - Show matching components

21. **Add JSON output support for ui commands**
    - `tracks ui list --json`
    - Machine-readable output
    - Document JSON schema

22. **Create unit tests for ui commands**
    - Test command routing
    - Test argument parsing
    - Test error handling

23. **Create integration tests for ui commands**
    - Test `tracks ui add` end-to-end
    - Test `tracks ui list` output
    - Verify components added correctly

24. **Document ui command reference**
    - All subcommands
    - Flags and arguments
    - Usage examples

25. **Add ui commands to main README**
    - Quick reference
    - Link to full documentation
    - Common workflows

### Phase 3: Component Examples (Tasks 26-35)

26. **Create form example page**
    - Login form with button, input, label
    - Registration form with validation
    - Use templ-ui form components

27. **Create layout example page**
    - Card grid layout
    - Sidebar navigation
    - Tabs for content organization

28. **Create feedback example page**
    - Alert messages (success, error, warning, info)
    - Toast notifications
    - Progress bars and spinners

29. **Create modal example**
    - Button to trigger modal
    - Modal with form
    - Close and submit actions

30. **Create accordion example**
    - FAQ page with accordion
    - Multiple sections
    - Open/close animations

31. **Create sheet example**
    - Slide-over panel
    - Settings drawer
    - Close on overlay click

32. **Update home page to showcase components**
    - Hero section with buttons
    - Feature cards
    - CTA with alert

33. **Create component gallery page**
    - Show all installed components
    - Interactive examples
    - Copy code snippets

34. **Add dark mode examples**
    - All components in dark mode
    - Theme toggle integration
    - Document dark mode usage

35. **Document component examples**
    - Link to example pages
    - Show code snippets
    - Explain customization

### Phase 4: Customization Workflow (Tasks 36-45)

36. **Document component ownership model**
    - "Copy code, own components" philosophy
    - Users can modify freely
    - No upstream conflicts

37. **Create customization guide**
    - How to modify components
    - Props and variants
    - Best practices

38. **Document component props**
    - Required vs optional props
    - Type information
    - Default values

39. **Create component variant guide**
    - Adding new variants
    - Customizing colors
    - Sizing options

40. **Document Tailwind customization**
    - Modifying component styles
    - Adding new utility classes
    - Theme integration

41. **Create component composition guide**
    - Building complex components
    - Nesting components
    - Passing components as props

42. **Document accessibility considerations**
    - ARIA attributes
    - Keyboard navigation
    - Screen reader support

43. **Create component testing guide**
    - Testing custom components
    - Props validation
    - Rendering tests

44. **Document update strategy**
    - When to update from upstream
    - Managing custom modifications
    - Conflict resolution

45. **Create component library best practices**
    - Organization patterns
    - Naming conventions
    - Documentation

### Phase 5: Advanced Features (Tasks 46-50)

46. **Add `tracks ui init` for existing projects**
    - Initialize templ-ui in existing app
    - Install starter set
    - Update configuration

47. **Create component dependencies tracking**
    - Track which components are installed
    - Show component relationships
    - Document dependencies

48. **Add component versioning info**
    - Track templ-ui version used
    - Document version in templui.yaml
    - Show version in `tracks ui list`

49. **Create component upgrade workflow**
    - Check for component updates
    - Show changelog
    - Selective upgrades

50. **Document production usage**
    - Component bundle size
    - Performance considerations
    - Optimization tips

## Dependencies

### Prerequisites

- Phase 0 completed (project generation working)
- Epic 1.1 completed (Chi router)
- Epic 1.2 completed (Templ templates)
- Epic 1.3 completed (HashFS assets)
- Epic 1.4 completed (TailwindCSS and Alpine.js)
- Go 1.25+ (tool directive support)

### External Dependencies

- `github.com/templui/templui` - Component library and CLI
- TailwindCSS (from Epic 1.4)
- Alpine.js (from Epic 1.4)
- templ (from Epic 1.2)

### Blocks

- Epic 1.6 (Documentation) - needs component examples

## Acceptance Criteria

### Templui Installation

- [ ] Templui CLI added to tool directive
- [ ] `templui init` runs during `tracks new`
- [ ] Starter component set installed automatically
- [ ] Components copied to `internal/http/views/components/ui/`
- [ ] templui.yaml configuration created
- [ ] Tailwind config updated for templ-ui styles

### tracks ui Commands

- [ ] `tracks ui add <component>` installs component
- [ ] `tracks ui list` shows available and installed components
- [ ] `tracks ui update <component>` updates from upstream
- [ ] `tracks ui remove <component>` removes component
- [ ] `tracks ui search <query>` finds components
- [ ] JSON output support (`--json` flag)
- [ ] Error handling with helpful messages

### Examples & Documentation

- [ ] Form example page created
- [ ] Layout example page created
- [ ] Feedback example page created
- [ ] Component gallery page created
- [ ] Dark mode examples working
- [ ] Customization guide documented
- [ ] Component ownership model explained

### Testing

- [ ] Unit tests for ui commands pass
- [ ] Integration tests verify component installation
- [ ] Example pages render correctly
- [ ] Components work in dark mode

## Technical Notes

### Templui Configuration

```yaml
# templui.yaml
# Generated by tracks during project creation

# Component output directory
components_dir: internal/http/views/components/ui

# Templ-UI version
version: 0.1.0

# Installed components (tracked automatically)
installed:
  - button
  - input
  - textarea
  - label
  - checkbox
  - radio
  - select
  - card
  - modal
  - dialog
  - sidebar
  - tabs
  - accordion
  - sheet
  - alert
  - toast
  - progress
  - spinner
  - skeleton
```

### ProjectGenerator Integration

```go
// internal/generator/project_generator.go

func (g *ProjectGenerator) Generate(ctx context.Context, cfg ProjectConfig) error {
    // ... existing generation steps

    // Install templ-ui after basic structure created
    if err := g.installTemplUI(ctx, cfg); err != nil {
        return fmt.Errorf("failed to install templ-ui: %w", err)
    }

    return nil
}

func (g *ProjectGenerator) installTemplUI(ctx context.Context, cfg ProjectConfig) error {
    logger := zerolog.Ctx(ctx)

    // Initialize templui
    logger.Info().Msg("initializing templ-ui")
    initCmd := exec.CommandContext(ctx, "go", "tool", "templui", "init")
    initCmd.Dir = cfg.ProjectDir
    if err := initCmd.Run(); err != nil {
        return fmt.Errorf("templui init failed: %w", err)
    }

    // Install starter component set
    components := []string{
        // Forms
        "button", "input", "textarea", "label",
        "checkbox", "radio", "select",
        // Layout
        "card", "modal", "dialog", "sidebar",
        "tabs", "accordion", "sheet",
        // Feedback
        "alert", "toast", "progress", "spinner", "skeleton",
    }

    for _, component := range components {
        logger.Info().Str("component", component).Msg("installing component")

        addCmd := exec.CommandContext(ctx, "go", "tool", "templui", "add", component)
        addCmd.Dir = cfg.ProjectDir
        if err := addCmd.Run(); err != nil {
            return fmt.Errorf("failed to install %s: %w", component, err)
        }
    }

    logger.Info().Msg("templ-ui installation complete")
    return nil
}
```

### tracks ui add Command

```go
// internal/cli/commands/ui_add.go
package commands

import (
    "context"
    "os/exec"
    "github.com/spf13/cobra"
)

type UIAddCommand struct {
    renderer interfaces.Renderer
    logger   interfaces.Logger
}

func NewUIAddCommand(renderer interfaces.Renderer, logger interfaces.Logger) *cobra.Command {
    cmd := &UIAddCommand{
        renderer: renderer,
        logger:   logger,
    }

    cobraCmd := &cobra.Command{
        Use:   "add <component>",
        Short: "Add a templ-ui component to your project",
        Args:  cobra.ExactArgs(1),
        RunE:  cmd.Run,
    }

    cobraCmd.Flags().BoolP("force", "f", false, "Overwrite existing component")

    return cobraCmd
}

func (c *UIAddCommand) Run(cmd *cobra.Command, args []string) error {
    ctx := cmd.Context()
    component := args[0]
    force, _ := cmd.Flags().GetBool("force")

    c.renderer.Info(fmt.Sprintf("Adding component: %s", component))

    // Build templui command
    templUIArgs := []string{"tool", "templui", "add", component}
    if force {
        templUIArgs = append(templUIArgs, "--force")
    }

    templUICmd := exec.CommandContext(ctx, "go", templUIArgs...)
    templUICmd.Stdout = os.Stdout
    templUICmd.Stderr = os.Stderr

    if err := templUICmd.Run(); err != nil {
        c.renderer.Error(fmt.Sprintf("Failed to add component: %s", err))
        return err
    }

    c.renderer.Success(fmt.Sprintf("Component '%s' added successfully", component))
    return nil
}
```

### tracks ui list Command

```go
// internal/cli/commands/ui_list.go
package commands

type UIListCommand struct {
    renderer interfaces.Renderer
}

func NewUIListCommand(renderer interfaces.Renderer) *cobra.Command {
    cmd := &UIListCommand{
        renderer: renderer,
    }

    cobraCmd := &cobra.Command{
        Use:   "list",
        Short: "List available templ-ui components",
        RunE:  cmd.Run,
    }

    cobraCmd.Flags().Bool("json", false, "Output as JSON")

    return cobraCmd
}

func (c *UIListCommand) Run(cmd *cobra.Command, args []string) error {
    ctx := cmd.Context()
    jsonOutput, _ := cmd.Flags().GetBool("json")

    // Run templui list command
    templUICmd := exec.CommandContext(ctx, "go", "tool", "templui", "list")
    output, err := templUICmd.CombinedOutput()
    if err != nil {
        return fmt.Errorf("failed to list components: %w", err)
    }

    if jsonOutput {
        // Parse and output JSON
        fmt.Println(string(output))
    } else {
        // Format as table using Renderer
        c.renderer.Section(renderer.Section{
            Title: "Available Components",
            Body:  string(output),
        })
    }

    return nil
}
```

### Example Form Using Templ-UI

```templ
// internal/http/views/pages/login.templ
package pages

import (
    "myapp/internal/http/views/layouts"
    "myapp/internal/http/views/components/ui"
)

type LoginPageProps struct {
    CSRFToken string
    Errors    map[string]string
}

templ LoginPage(props LoginPageProps) {
    @layouts.Base("Login") {
        <div class="container max-w-md mx-auto mt-8">
            @ui.Card(ui.CardProps{
                Title: "Login",
            }) {
                <form hx-post="/login" hx-target="#login-result">
                    <input type="hidden" name="csrf_token" value={ props.CSRFToken }/>

                    @ui.Input(ui.InputProps{
                        Name:        "email",
                        Label:       "Email",
                        Type:        "email",
                        Required:    true,
                        Placeholder: "you@example.com",
                        Error:       props.Errors["email"],
                    })

                    @ui.Input(ui.InputProps{
                        Name:        "password",
                        Label:       "Password",
                        Type:        "password",
                        Required:    true,
                        Error:       props.Errors["password"],
                    })

                    @ui.Button(ui.ButtonProps{
                        Type:    "submit",
                        Variant: "primary",
                        Label:   "Login",
                    })
                </form>

                <div id="login-result"></div>
            }
        </div>
    }
}
```

### Customizing Components

Users can modify components freely since they own the code:

```templ
// internal/http/views/components/ui/button.templ
// This file is copied from templ-ui and owned by the project
// Feel free to customize!

package ui

type ButtonProps struct {
    Label    string
    Type     string  // "button" | "submit" | "reset"
    Variant  string  // "primary" | "secondary" | "danger"
    Size     string  // "sm" | "md" | "lg"
    Disabled bool
}

templ Button(props ButtonProps) {
    <button
        type={ props.Type }
        class={ helpers.ClassNames(map[string]bool{
            "btn": true,
            "btn-primary": props.Variant == "primary",
            "btn-secondary": props.Variant == "secondary",
            "btn-danger": props.Variant == "danger",
            "btn-sm": props.Size == "sm",
            "btn-md": props.Size == "md" || props.Size == "",
            "btn-lg": props.Size == "lg",
            // ADD YOUR CUSTOM CLASSES HERE
            "btn-custom": props.Variant == "custom",
        }) }
        if props.Disabled {
            disabled
        }
    >
        { props.Label }
    </button>
}
```

### Tailwind Configuration for Templ-UI

```javascript
// tailwind.config.js
module.exports = {
  content: [
    './internal/http/views/**/*.templ',
    // Scan templ-ui components
    './internal/http/views/components/ui/**/*.templ',
  ],
  darkMode: 'class',
  theme: {
    extend: {
      // Templ-UI uses these colors by default
      // Customize to match your brand
      colors: {
        primary: {
          50: '#f0f9ff',
          // ... more shades
        },
      },
    },
  },
  plugins: [],
}
```

### Component Directory Structure

```text
internal/http/views/components/
├── ui/                      # Templ-UI library components (owned by you)
│   ├── button.templ
│   ├── input.templ
│   ├── textarea.templ
│   ├── label.templ
│   ├── checkbox.templ
│   ├── radio.templ
│   ├── select.templ
│   ├── card.templ
│   ├── modal.templ
│   ├── dialog.templ
│   ├── sidebar.templ
│   ├── tabs.templ
│   ├── accordion.templ
│   ├── sheet.templ
│   ├── alert.templ
│   ├── toast.templ
│   ├── progress.templ
│   ├── spinner.templ
│   └── skeleton.templ
├── nav.templ               # Your custom components
├── footer.templ
└── meta.templ
```

**Rationale for `ui/` nesting:**

1. **Clear ownership boundaries** - Easy to identify templ-ui components vs custom
2. **Update isolation** - Know what's affected when updating via `tracks ui add`
3. **Namespace clarity** - `@ui.Button()` vs `@components.CustomForm()`
4. **Organizational scalability** - Separation remains clear as project grows

See [ADR-009](../../../adr/009-templui-for-ui-components.md) for detailed rationale.

### Update Workflow

When templ-ui releases updates:

```bash
# Update specific component
tracks ui update button

# Shows diff before updating
# User chooses to apply or cancel

# If user has modified the component:
# - Save backup to button.templ.bak
# - Show warning about custom modifications
# - User decides whether to proceed
```

## Testing Strategy

### Unit Tests

- `tracks ui add` command parsing
- `tracks ui list` output formatting
- Component name validation
- Error handling

### Integration Tests

- Run `tracks new` and verify templ-ui installed
- Run `tracks ui add calendar` and verify component added
- Run `tracks ui list` and verify output
- Test component rendering in browser

### Manual Testing

- Install all starter components
- Customize a component
- Update from upstream (verify custom changes preserved)
- Test in dark mode
- Test on mobile viewport

## Next Epic

[Epic 1.6: Middleware Stack & Documentation →](./1.6-middleware-documentation.md)
