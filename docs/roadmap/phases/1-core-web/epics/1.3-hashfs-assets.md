# Epic 1.3: HashFS Assets

[← Back to Phase 1](../1-core-web.md) | [← Epic 1.2](./1.2-templ-templates.md)

## Overview

Implement content-addressed asset serving using Ben Johnson's hashfs library. This epic establishes automatic asset embedding with `go:embed`, content-based cache busting through SHA-256 hashing, optimal cache headers for browser caching, and compression support. HashFS ensures deployed assets have immutable URLs that can be cached forever, while content changes automatically generate new URLs.

## Goals

- Asset embedding with `go:embed` directive
- Content-based hash generation (SHA-256) for cache busting
- Immutable asset URLs with far-future cache headers
- Compression support (gzip, brotli)
- Asset helper functions for templates
- Development vs production asset modes
- Static file serving integrated with Chi router
- Image optimization workflow

## Scope

### In Scope

- HashFS integration (`github.com/benbjohnson/hashfs`)
- Asset embedding from `web/` directory
- Content hash generation for all static files
- Cache header configuration (1 year for hashed assets)
- Helper functions for asset URLs in templates
- Compression middleware (gzip via chi middleware)
- Development mode (direct file serving, no caching)
- Production mode (embedded + hashed + cached)
- Asset directory structure (`web/css/`, `web/js/`, `web/images/`)
- Chi route for serving static files
- Asset URL generation helper

### Out of Scope

- TailwindCSS compilation (Epic 1.4)
- JavaScript bundling with esbuild (Epic 1.4)
- Alpine.js integration (Epic 1.4)
- Image processing/optimization (basic support only)
- CDN integration (future)
- Service worker / offline support (future)
- Asset preloading strategies (future)

## Task Breakdown

The following tasks will become GitHub issues, ordered by dependency:

### Phase 1: HashFS Foundation (Tasks 1-10)

1. **Add hashfs dependency to generated go.mod**
   - Add `github.com/benbjohnson/hashfs`
   - Document version constraints

2. **Create asset directory structure**
   - `web/css/` - Stylesheets
   - `web/js/` - JavaScript files
   - `web/images/` - Images and icons
   - `web/fonts/` - Web fonts (if needed)

3. **Create assets package (internal/assets/assets.go)**
   - Package for asset management
   - Embed directive for web directory
   - HashFS initialization

4. **Implement asset embedding with go:embed**
   - Embed entire `web/` directory
   - Create `embed.FS` variable
   - Document embedding patterns

5. **Initialize hashFS in assets package**
   - Wrap embedded FS with hashfs
   - Generate SHA-256 hashes
   - Create hash map

6. **Add asset helper function for URL generation**
   - `AssetURL(path string) string`
   - Returns content-hashed URL
   - Handles missing files gracefully

7. **Create development mode asset serving**
   - Direct file serving without hashing
   - No caching for rapid development
   - File watcher friendly

8. **Add production mode with hashing**
   - Serve from embedded FS
   - Content-hashed URLs
   - Immutable cache headers

9. **Create environment-based mode selection**
   - `APP_ENV=development` - dev mode
   - `APP_ENV=production` - prod mode
   - Default to development

10. **Document asset embedding workflow**
    - How assets are embedded
    - Hash generation process
    - URL generation

### Phase 2: Chi Integration (Tasks 11-20)

1. **Create static file handler**
    - Serve assets from hashFS
    - Handle 404s gracefully
    - Set proper MIME types

2. **Register asset route in Chi router**
    - `/assets/*` route
    - Use FileServer pattern
    - Document route setup

3. **Add cache headers for hashed assets**
    - `Cache-Control: public, max-age=31536000, immutable`
    - 1 year caching for hashed files
    - No caching for non-hashed files

4. **Implement ETag support**
    - Generate ETags from content hash
    - Handle `If-None-Match` requests
    - Return 304 Not Modified when appropriate

5. **Add compression middleware**
    - Use `chi.Compress()` middleware
    - gzip compression for text assets
    - Document compression setup

6. **Create asset middleware for headers**
    - Set `Content-Type` based on file extension
    - Add security headers (X-Content-Type-Options)
    - Document middleware chain

7. **Add CORS headers for fonts**
    - Allow cross-origin font loading
    - `Access-Control-Allow-Origin: *` for fonts
    - Document font serving

8. **Implement range request support**
    - Support partial content requests (206)
    - Useful for large files and streaming
    - Document range handling

9. **Create asset serving tests**
    - Test file serving
    - Test cache headers
    - Test 404 handling

10. **Document static file serving**
    - Route configuration
    - Middleware chain
    - Cache strategy

### Phase 3: Template Helpers (Tasks 21-30)

1. **Create AssetURL helper for templates**
    - Templ-compatible helper
    - Returns `templ.SafeURL`
    - Handles development vs production

2. **Add CSS helper (CSS function)**
    - `CSS(path string) templ.SafeURL`
    - Convenience wrapper for stylesheets
    - Usage: `@CSS("app.css")`

3. **Add JS helper (JS function)**
    - `JS(path string) templ.SafeURL`
    - Convenience wrapper for scripts
    - Usage: `@JS("app.js")`

4. **Add Image helper (Image function)**
    - `Image(path string) templ.SafeURL`
    - Convenience wrapper for images
    - Usage: `@Image("logo.png")`

5. **Create preload helper for critical assets**
    - Generate `<link rel="preload">` tags
    - For critical CSS and JavaScript
    - Improve page load performance

6. **Add favicon helpers**
    - Generate favicon link tags
    - Support multiple sizes
    - Apple touch icons

7. **Update base layout to use asset helpers**
    - Replace hardcoded URLs
    - Use `@CSS()`, `@JS()` helpers
    - Document usage

8. **Create asset manifest generation (optional)**
    - Map original paths to hashed paths
    - JSON manifest for debugging
    - Document manifest format

9. **Add inline asset helper (for critical CSS)**
    - Inline small CSS for above-the-fold content
    - `InlineCSS(path string) templ.Component`
    - Document when to inline

10. **Document template asset helpers**
    - Helper function reference
    - Usage examples
    - Best practices

### Phase 4: Asset Optimization (Tasks 31-40)

1. **Create image optimization documentation**
    - Recommended formats (WebP, AVIF)
    - Sizing guidelines
    - Compression tools

2. **Add SVG optimization workflow**
    - SVGO integration (optional)
    - Inline SVG vs external
    - Document SVG usage

3. **Create responsive image helper**
    - Generate `srcset` attributes
    - Support multiple image sizes
    - Props: `Src`, `Sizes`, `Alt`

4. **Add lazy loading support**
    - `loading="lazy"` attribute
    - Intersection Observer fallback
    - Document lazy loading

5. **Implement image placeholder pattern**
    - Low-quality image placeholders (LQIP)
    - Blur-up effect
    - Document implementation

6. **Create font loading strategy**
    - `font-display: swap` by default
    - Preload critical fonts
    - Document font optimization

7. **Add asset size budgets (documentation)**
    - Recommended max sizes
    - Total page weight targets
    - Monitoring tools

8. **Create asset inventory script**
    - List all embedded assets
    - Show file sizes
    - Identify optimization opportunities

9. **Add asset versioning for cache invalidation**
    - Content hash IS the version
    - Document hash-based versioning
    - No manual version numbers needed

10. **Document asset performance best practices**
    - Critical CSS inlining
    - JavaScript defer/async
    - Image optimization
    - Font loading

## Dependencies

### Prerequisites

- Phase 0 completed (project generation working)
- Epic 1.1 completed (Chi router)
- Epic 1.2 completed (Templ templates)
- Go 1.25+ (embed directive support)

### External Dependencies

- `github.com/benbjohnson/hashfs` - Content-addressed file system
- `github.com/go-chi/chi/v5/middleware` - Compression middleware
- Standard library: `embed`, `net/http`, `io/fs`

### Blocks

- Epic 1.4 (Web Build Pipeline) - needs asset serving for compiled CSS/JS
- Epic 1.5 (Templ-UI Integration) - needs asset helpers in components

## Acceptance Criteria

### Asset Infrastructure

- [ ] HashFS initialized with embedded assets
- [ ] Asset directory structure created (`web/css/`, `web/js/`, `web/images/`)
- [ ] go:embed directive embeds `web/` directory
- [ ] Content hashes generated for all assets (SHA-256)
- [ ] Development mode serves files directly without hashing
- [ ] Production mode serves embedded hashed assets

### Serving & Caching

- [ ] `/assets/*` route registered in Chi router
- [ ] Cache headers set correctly (1 year for hashed assets)
- [ ] ETag support for conditional requests (304 responses)
- [ ] Compression middleware enabled (gzip)
- [ ] MIME types set correctly for all file types
- [ ] 404 handling for missing assets

### Template Integration

- [ ] AssetURL helper returns content-hashed URLs
- [ ] CSS, JS, Image helpers available in templates
- [ ] Base layout uses asset helpers
- [ ] Helpers work in both development and production modes
- [ ] Preload helpers generate correct link tags

### Documentation

- [ ] Asset embedding workflow documented
- [ ] Cache strategy documented
- [ ] Template helpers documented with examples
- [ ] Asset optimization best practices guide created

## Technical Notes

### Asset Embedding with go:embed

Embed the entire `web/` directory at compile time:

```go
// internal/assets/assets.go
package assets

import (
    "embed"
    "io/fs"
    "github.com/benbjohnson/hashfs"
)

//go:embed web/*
var embeddedFiles embed.FS

// FS is the content-addressed filesystem for assets
var FS *hashfs.FS

func init() {
    // Strip "web/" prefix from paths
    webFS, err := fs.Sub(embeddedFiles, "web")
    if err != nil {
        panic(err)
    }

    // Wrap with hashfs for content-based hashing
    FS = hashfs.NewFS(webFS)
}
```

### Development vs Production Modes

```go
// internal/assets/assets.go

import "os"

var FS *hashfs.FS

func init() {
    if os.Getenv("APP_ENV") == "production" {
        // Production: embedded FS with content hashing
        webFS, _ := fs.Sub(embeddedFiles, "web")
        FS = hashfs.NewFS(webFS)
    } else {
        // Development: direct OS filesystem (no embedding)
        // Allows for file watching and rapid iteration
        FS = hashfs.NewFS(os.DirFS("web"))
    }
}
```

### AssetURL Helper

Generate content-hashed URLs:

```go
// internal/assets/helpers.go
package assets

import (
    "github.com/a-h/templ"
)

// AssetURL returns the content-hashed URL for an asset
func AssetURL(path string) templ.SafeURL {
    hashedPath := FS.HashName(path)
    return templ.URL("/assets/" + hashedPath)
}

// CSS is a convenience wrapper for stylesheets
func CSS(path string) templ.SafeURL {
    return AssetURL("css/" + path)
}

// JS is a convenience wrapper for scripts
func JS(path string) templ.SafeURL {
    return AssetURL("js/" + path)
}

// Image is a convenience wrapper for images
func Image(path string) templ.SafeURL {
    return AssetURL("images/" + path)
}
```

### Chi Router Integration

Serve assets with proper headers:

```go
// internal/http/routes.go
package http

import (
    "net/http"
    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
    "myapp/internal/assets"
    "myapp/internal/http/routes"
)

func (s *Server) routes() {
    // Compression middleware for all routes
    s.router.Use(middleware.Compress(5))

    // Serve static assets
    s.router.Get(routes.Assets, func(w http.ResponseWriter, r *http.Request) {
        // Strip "/assets/" prefix
        path := r.URL.Path[8:]

        // Open file from hashFS
        file, err := assets.FS.Open(path)
        if err != nil {
            http.NotFound(w, r)
            return
        }
        defer file.Close()

        // Get file info for ETag
        info, err := file.Stat()
        if err != nil {
            http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            return
        }

        // Set cache headers for hashed assets
        // HashFS paths contain content hash, so they're immutable
        w.Header().Set("Cache-Control", "public, max-age=31536000, immutable")
        w.Header().Set("X-Content-Type-Options", "nosniff")

        // Serve file
        http.ServeContent(w, r, info.Name(), info.ModTime(), file.(io.ReadSeeker))
    })

    // ... other routes
}
```

### Using Asset Helpers in Templates

```templ
// internal/http/views/layouts/base.templ
package layouts

import "myapp/internal/assets"

templ Base(title string) {
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
        <title>{ title }</title>

        // CSS with content-hashed URL
        <link rel="stylesheet" href={ string(assets.CSS("app.css")) }/>

        // Preload critical JavaScript
        <link rel="preload" href={ string(assets.JS("app.js")) } as="script"/>

        // JavaScript with defer
        <script src={ string(assets.JS("app.js")) } defer></script>
    </head>
    <body>
        { children... }
    </body>
    </html>
}
```

### Image Component with Asset Helper

```templ
// internal/http/views/components/logo.templ
package components

import "myapp/internal/assets"

templ Logo(size string) {
    <img
        src={ string(assets.Image("logo.png")) }
        alt="Company Logo"
        width={ size }
        height={ size }
    />
}
```

### Responsive Image Helper

```go
// internal/assets/helpers.go

type ImageSrcSet struct {
    Path  string
    Sizes []string // ["logo.png", "logo@2x.png", "logo@3x.png"]
}

func (s ImageSrcSet) SrcSet() string {
    var parts []string
    for i, size := range s.Sizes {
        hashedPath := FS.HashName("images/" + size)
        descriptor := fmt.Sprintf("%dx", i+1)
        parts = append(parts, fmt.Sprintf("/assets/%s %s", hashedPath, descriptor))
    }
    return strings.Join(parts, ", ")
}
```

Usage in template:

```templ
templ ResponsiveLogo() {
    <img
        src={ string(assets.Image("logo.png")) }
        srcset={ assets.ImageSrcSet{
            Path: "logo",
            Sizes: []string{"logo.png", "logo@2x.png", "logo@3x.png"},
        }.SrcSet() }
        alt="Logo"
    />
}
```

### Cache Headers Strategy

**Hashed assets (immutable):**

```http
Cache-Control: public, max-age=31536000, immutable
ETag: "abc123..."
```

Content hash in URL = URL changes when content changes = safe to cache forever.

**Non-hashed assets (HTML pages):**

```http
Cache-Control: no-cache
ETag: "xyz789..."
```

HTML can change frequently, so always revalidate with server.

### ETag Generation

HashFS automatically provides content hash for ETags:

```go
func serveAsset(w http.ResponseWriter, r *http.Request, path string) {
    file, _ := assets.FS.Open(path)
    defer file.Close()

    info, _ := file.Stat()

    // Use content hash as ETag
    etag := `"` + assets.FS.HashName(path) + `"`
    w.Header().Set("ETag", etag)

    // Check If-None-Match
    if match := r.Header.Get("If-None-Match"); match == etag {
        w.WriteHeader(http.StatusNotModified)
        return
    }

    // Serve file...
}
```

### Font Loading Strategy

```css
/* web/css/fonts.css */
@font-face {
  font-family: 'Inter';
  src: url('/assets/fonts/inter-var.woff2') format('woff2');
  font-weight: 100 900;
  font-display: swap; /* Show fallback font immediately */
}
```

Preload critical fonts:

```templ
<link
    rel="preload"
    href={ string(assets.AssetURL("fonts/inter-var.woff2")) }
    as="font"
    type="font/woff2"
    crossorigin
/>
```

### Inline Critical CSS

For above-the-fold content:

```go
func InlineCSS(path string) templ.Component {
    data, _ := assets.FS.ReadFile("css/" + path)
    return templ.Raw(fmt.Sprintf("<style>%s</style>", data))
}
```

Use sparingly - only for critical CSS to prevent render blocking.

## Testing Strategy

### Unit Tests

- AssetURL helper returns correct hashed URLs
- CSS, JS, Image helpers work correctly
- Development vs production mode selection
- Helper functions handle missing files gracefully

### Integration Tests

- Static file serving returns correct content
- Cache headers set correctly
- ETag support works (304 responses)
- Compression enabled for text assets
- 404 for missing assets

### Performance Tests

- Asset serving latency
- Compression ratio for text assets
- Cache hit rates (manual testing)

## Next Epic

[Epic 1.4: Web Build Pipeline →](./1.4-web-build-pipeline.md)
