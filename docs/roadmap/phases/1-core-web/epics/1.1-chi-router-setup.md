# Epic 1.1: Chi Router Setup

[← Back to Phase 1](../1-core-web.md)

## Overview

Establish the Chi router foundation for generated web applications. This epic implements the HTTP server structure with builder-pattern dependency injection, graceful shutdown handling, and the basic route registration system. This creates the foundation for all subsequent web layer features including middleware, templates, and assets.

## Goals

- Chi v5 router integrated into generated projects
- Builder-pattern server structure with dependency injection
- Graceful shutdown with context-based signal handling
- Route constants pattern for compile-time safety
- Route helper functions for type-safe URL generation
- Comprehensive HTTP configuration (timeouts, headers, TLS)
- Health check endpoint for Kubernetes/load balancer probes
- Static file serving preparation (hashfs integration in Epic 1.3)

## Scope

### In Scope

- Chi router initialization and configuration
- Server struct with builder-pattern dependency injection
- Route constants file (`internal/http/routes/routes.go`)
- Route helper functions for templ templates
- Graceful shutdown with signal handling (SIGINT, SIGTERM)
- HTTP server configuration (read/write timeouts, max header bytes)
- Health check handler (`/health`)
- Basic route registration pattern
- Server entry point in `cmd/server/main.go`
- HTTP configuration via environment variables (port, host, timeouts)
- Cross-platform signal handling

### Out of Scope

- Middleware implementation (Epic 1.6)
- Template rendering (Epic 1.2)
- Asset serving with hashfs (Epic 1.3)
- TailwindCSS and Alpine.js (Epic 1.4)
- Templ-UI components (Epic 1.5)
- Authentication/authorization (Phase 3)
- Database connectivity (Phase 2)
- Full CRUD handlers (future epics)

## Task Breakdown

The following tasks will become GitHub issues, ordered by dependency:

### Phase 1: Chi Router Foundation (Tasks 1-8)

1. **Add Chi v5 dependency to generated go.mod**
   - Add `github.com/go-chi/chi/v5` to template
   - Document version constraints

2. **Create server.go with Server struct and builder pattern**
   - Define `Server` struct with router and config fields
   - Implement `NewServer(cfg *Config)` constructor
   - Add builder methods: `WithHealthService()`, `WithLogger()`, etc.
   - Implement `RegisterRoutes()` method

3. **Create Config struct for HTTP server configuration**
   - Port, Host, ReadTimeout, WriteTimeout, IdleTimeout
   - MaxHeaderBytes, TLSCertFile, TLSKeyFile
   - Load from environment variables via Viper

4. **Implement graceful shutdown with signal handling**
   - Listen for SIGINT and SIGTERM
   - Create context with timeout for shutdown
   - Wait for in-flight requests to complete
   - Log shutdown events

5. **Create routes constants file (internal/http/routes/routes.go)**
   - Define route path constants (Home, Health, etc.)
   - Group by category (pages, actions, static)
   - Document naming conventions

6. **Add route helper functions for path generation**
   - String helpers: `UserProfilePath(username string) string`
   - templ helpers: `UserProfileURL(username string) templ.SafeURL`
   - Document usage patterns

7. **Create health check handler**
   - Simple `GET /health` endpoint returning 200 OK
   - JSON response: `{"status": "ok", "timestamp": "..."}`
   - Used by Kubernetes liveness/readiness probes

8. **Wire up basic route registration in routes() method**
   - Register health check
   - Register home page (placeholder)
   - Document route registration pattern

### Phase 2: Server Entry Point (Tasks 9-15)

1. **Create cmd/server/main.go entry point**
   - Parse flags and environment variables
   - Initialize configuration
   - Set up logger
   - Create server and register routes

2. **Add server configuration loading via Viper**
    - Environment variable prefix (e.g., `APP_`)
    - `.env` file support (development)
    - Default values for all config options

3. **Implement ListenAndServe() with http.Server configuration**
    - Set timeouts from config
    - Configure max header bytes
    - Enable keep-alive
    - Log server start message

4. **Add TLS support for HTTPS**
    - Check for cert/key file configuration
    - Fall back to HTTP if TLS not configured
    - Document certificate setup

5. **Create Makefile target for running server**
    - `make run-server` - start server locally
    - `make dev` - run with Air for live reload (Epic 1.4)
    - Document development workflow

6. **Add context propagation through request lifecycle**
    - Context with timeout for shutdown
    - Request-scoped context in handlers
    - Document context usage patterns

7. **Create server unit tests**
    - Test server creation and configuration
    - Test builder pattern methods
    - Test route registration

### Phase 3: Route Patterns & Templates (Tasks 16-22)

1. **Generate route constants template in internal/templates/**
    - Template for routes.go generation
    - Placeholder routes (health, home, about)
    - Comment documentation

2. **Generate server.go template**
    - Server struct template
    - Builder pattern methods
    - Route registration skeleton

3. **Generate main.go template for cmd/server/**
    - Configuration loading
    - Signal handling
    - Server initialization and shutdown

4. **Generate HTTP config template for .env.example**
    - All HTTP configuration options
    - Sensible defaults
    - Documentation comments

5. **Add route helper generation to ProjectGenerator**
    - Generate routes.go during `tracks new`
    - Generate server.go during `tracks new`
    - Generate main.go during `tracks new`

6. **Update Makefile template with server targets**
    - `run-server` target
    - `dev` target (calls Air when configured)
    - `build-server` target

7. **Document Chi router setup in generated README**
    - Server structure explanation
    - Route registration pattern
    - Configuration options
    - Development workflow

### Phase 4: Advanced Configuration (Tasks 23-30)

1. **Add request timeout middleware (chi built-in)**
    - Use `chi.Timeout()` middleware
    - Configure timeout from environment
    - Document timeout behavior

2. **Add max body size configuration**
    - Limit request body size
    - Return 413 Payload Too Large
    - Configure via environment variable

3. **Implement structured logging integration point**
    - Logger field in Server struct
    - `WithLogger()` builder method
    - Log server lifecycle events

4. **Add server shutdown timeout configuration**
    - Configurable via environment variable
    - Default to 30 seconds
    - Log forced shutdown if timeout exceeded

5. **Create integration test for server lifecycle**
    - Start server in test
    - Make HTTP request to /health
    - Trigger shutdown
    - Verify graceful shutdown

6. **Add HTTP/2 support**
    - Enable by default for TLS connections
    - Document HTTP/2 benefits
    - Test with h2 protocol

7. **Document hypermedia routing patterns**
    - GET (forms) vs POST (actions) separation
    - Slug-based URLs vs UUID-based
    - Route helper usage in templates

8. **Create Chi router troubleshooting guide**
    - Common issues (route conflicts, middleware order)
    - Debugging route registration
    - Performance tips

## Dependencies

### Prerequisites

- Phase 0 completed (project generation working)
- Go 1.25+ (tool directive support)

### External Dependencies

- `github.com/go-chi/chi/v5` - HTTP router
- `github.com/spf13/viper` - Configuration management (already in Phase 0)
- Standard library: `net/http`, `context`, `os/signal`, `syscall`

### Blocks

- Epic 1.2 (Templ Templates) - needs routes registered for template rendering
- Epic 1.3 (HashFS Assets) - needs static file route pattern
- Epic 1.6 (Middleware) - needs server and routes foundation

## Acceptance Criteria

### Server Infrastructure

- [ ] Chi v5 router initialized in generated projects
- [ ] Server struct uses builder pattern for dependency injection
- [ ] Graceful shutdown works on SIGINT and SIGTERM
- [ ] HTTP configuration loaded from environment variables
- [ ] Server listens on configured host and port
- [ ] Timeouts configured (read, write, idle, shutdown)

### Routing

- [ ] Route constants defined in `internal/http/routes/routes.go`
- [ ] Route helper functions generate type-safe paths
- [ ] templ.SafeURL helpers available for templates
- [ ] Health check endpoint returns 200 OK with JSON
- [ ] Routes organized by category (pages, actions, static)

### Configuration

- [ ] `.env.example` includes all HTTP configuration options
- [ ] Viper loads config from environment and .env file
- [ ] Default values provided for all config options
- [ ] TLS support works when cert/key files provided
- [ ] Configuration documented in generated README

### Testing & Documentation

- [ ] Server unit tests pass
- [ ] Integration test verifies server lifecycle
- [ ] Makefile includes run-server and dev targets
- [ ] README documents server structure and route patterns
- [ ] Troubleshooting guide created

## Technical Notes

### Server Structure with Builder Pattern

The Server uses dependency injection via builder methods for testability:

```go
// internal/http/server.go
package http

import (
    "context"
    "net/http"
    "time"
    "github.com/go-chi/chi/v5"
    "myapp/internal/interfaces"
)

type Server struct {
    router chi.Router
    config *Config

    // Injected dependencies
    healthService interfaces.HealthService
    logger        interfaces.Logger
}

func NewServer(cfg *Config) *Server {
    return &Server{
        router: chi.NewRouter(),
        config: cfg,
    }
}

// Builder pattern for dependency injection
func (s *Server) WithHealthService(svc interfaces.HealthService) *Server {
    s.healthService = svc
    return s
}

func (s *Server) WithLogger(log interfaces.Logger) *Server {
    s.logger = log
    return s
}

// Called after all dependencies injected
func (s *Server) RegisterRoutes() *Server {
    s.routes()
    return s
}

func (s *Server) ListenAndServe() error {
    srv := &http.Server{
        Addr:           s.config.Port,
        Handler:        s.router,
        ReadTimeout:    s.config.ReadTimeout,
        WriteTimeout:   s.config.WriteTimeout,
        IdleTimeout:    s.config.IdleTimeout,
        MaxHeaderBytes: s.config.MaxHeaderBytes,
    }

    if s.config.TLSCertFile != "" && s.config.TLSKeyFile != "" {
        return srv.ListenAndServeTLS(s.config.TLSCertFile, s.config.TLSKeyFile)
    }

    return srv.ListenAndServe()
}
```

### HTTP Configuration

```go
// internal/http/config.go
package http

import "time"

type Config struct {
    Host        string
    Port        string
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
    IdleTimeout  time.Duration
    ShutdownTimeout time.Duration
    MaxHeaderBytes int
    TLSCertFile string
    TLSKeyFile  string
}

func LoadConfig() *Config {
    viper.SetDefault("http.host", "0.0.0.0")
    viper.SetDefault("http.port", ":8080")
    viper.SetDefault("http.read_timeout", 15*time.Second)
    viper.SetDefault("http.write_timeout", 15*time.Second)
    viper.SetDefault("http.idle_timeout", 60*time.Second)
    viper.SetDefault("http.shutdown_timeout", 30*time.Second)
    viper.SetDefault("http.max_header_bytes", 1048576) // 1MB

    return &Config{
        Host:        viper.GetString("http.host"),
        Port:        viper.GetString("http.port"),
        ReadTimeout:  viper.GetDuration("http.read_timeout"),
        WriteTimeout: viper.GetDuration("http.write_timeout"),
        IdleTimeout:  viper.GetDuration("http.idle_timeout"),
        ShutdownTimeout: viper.GetDuration("http.shutdown_timeout"),
        MaxHeaderBytes: viper.GetInt("http.max_header_bytes"),
        TLSCertFile: viper.GetString("http.tls_cert_file"),
        TLSKeyFile:  viper.GetString("http.tls_key_file"),
    }
}
```

### Graceful Shutdown

```go
// cmd/server/main.go
func main() {
    cfg := http.LoadConfig()

    server := http.NewServer(cfg).
        WithHealthService(healthService).
        WithLogger(logger).
        RegisterRoutes()

    // Run server in goroutine
    serverErrors := make(chan error, 1)
    go func() {
        log.Info().Str("addr", cfg.Port).Msg("starting server")
        serverErrors <- server.ListenAndServe()
    }()

    // Listen for shutdown signals
    shutdown := make(chan os.Signal, 1)
    signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

    select {
    case err := <-serverErrors:
        log.Fatal().Err(err).Msg("server error")

    case sig := <-shutdown:
        log.Info().Str("signal", sig.String()).Msg("shutdown signal received")

        // Create context with timeout for shutdown
        ctx, cancel := context.WithTimeout(context.Background(), cfg.ShutdownTimeout)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil {
            log.Error().Err(err).Msg("graceful shutdown failed")
            if err := server.Close(); err != nil {
                log.Fatal().Err(err).Msg("forced shutdown failed")
            }
        }
    }
}
```

### Route Constants and Helpers

```go
// internal/http/routes/routes.go
package routes

import "github.com/a-h/templ"

const (
    // Pages (GET only)
    Home          = "/"
    About         = "/about"
    Health        = "/health"

    // User profiles (slugs not IDs)
    UserProfile   = "/u/{username}"
    EditProfile   = "/settings/profile"

    // Content with slugs
    PostView      = "/p/{slug}"
    PostNew       = "/write"
    PostEdit      = "/p/{slug}/edit"

    // Actions (POST only)
    CreatePost    = "/create-post"
    UpdatePost    = "/update-post"
    DeletePost    = "/delete-post"

    // Static
    Assets        = "/assets/*"
)

// String helpers for path generation
func UserProfilePath(username string) string {
    return "/u/" + username
}

func PostPath(slug string) string {
    return "/p/" + slug
}

func PostEditPath(slug string) string {
    return "/p/" + slug + "/edit"
}

// templ helpers for use in templates
func UserProfileURL(username string) templ.SafeURL {
    return templ.URL("/u/" + username)
}

func PostURL(slug string) templ.SafeURL {
    return templ.URL("/p/" + slug)
}

func PostEditURL(slug string) templ.SafeURL {
    return templ.URL("/p/" + slug + "/edit")
}
```

### Route Registration Pattern

```go
// internal/http/routes.go
package http

import (
    "net/http"
    "myapp/internal/http/handlers"
    "myapp/internal/http/routes"
)

func (s *Server) routes() {
    // Health check (no middleware)
    s.router.Get(routes.Health, handlers.HealthCheck)

    // Public routes
    s.router.Get(routes.Home, handlers.Home)
    s.router.Get(routes.About, handlers.About)

    // User profiles
    s.router.Get(routes.UserProfile, handlers.UserProfile)

    // Posts
    s.router.Get(routes.PostView, handlers.PostView)
    s.router.Get(routes.PostNew, handlers.PostNew)
    s.router.Post(routes.CreatePost, handlers.CreatePost)
}
```

### Health Check Handler

```go
// internal/http/handlers/health.go
package handlers

import (
    "encoding/json"
    "net/http"
    "time"
)

type HealthResponse struct {
    Status    string    `json:"status"`
    Timestamp time.Time `json:"timestamp"`
}

func HealthCheck(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)

    json.NewEncoder(w).Encode(HealthResponse{
        Status:    "ok",
        Timestamp: time.Now().UTC(),
    })
}
```

### Environment Configuration (.env.example)

```bash
# HTTP Server Configuration
APP_HTTP_HOST=0.0.0.0
APP_HTTP_PORT=:8080
APP_HTTP_READ_TIMEOUT=15s
APP_HTTP_WRITE_TIMEOUT=15s
APP_HTTP_IDLE_TIMEOUT=60s
APP_HTTP_SHUTDOWN_TIMEOUT=30s
APP_HTTP_MAX_HEADER_BYTES=1048576

# TLS Configuration (optional)
# APP_HTTP_TLS_CERT_FILE=/path/to/cert.pem
# APP_HTTP_TLS_KEY_FILE=/path/to/key.pem
```

### Hypermedia Route Patterns

Routes follow hypermedia principles:

**GET routes show forms/pages:**

- `/login` - Shows login form
- `/write` - Shows new post form
- `/p/{slug}/edit` - Shows edit form for existing post

**POST routes process actions:**

- `/create-post` - Processes new post creation
- `/update-post` - Processes post update
- `/delete-post` - Processes post deletion

**Use slugs, not UUIDs in URLs:**

- Good: `/u/johndoe`, `/p/my-first-post`
- Bad: `/users/123e4567-e89b-12d3-a456-426614174000`

UUIDs belong in forms and POST bodies, not public URLs.

## Testing Strategy

### Unit Tests

- Server struct creation and builder pattern
- Configuration loading from environment
- Route helper functions
- Health check handler

### Integration Tests

- Server lifecycle (start, request, graceful shutdown)
- Signal handling (SIGINT, SIGTERM)
- TLS configuration (if cert/key provided)
- Timeout enforcement

### Cross-Platform Tests

- Signal handling on Linux, macOS, Windows
- Path separator handling
- Environment variable loading

## Next Epic

[Epic 1.2: Templ Templates →](./1.2-templ-templates.md)
