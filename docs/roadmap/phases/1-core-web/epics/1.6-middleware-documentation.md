# Epic 1.6: Middleware Stack & Documentation

[← Back to Phase 1](../1-core-web.md) | [← Epic 1.5](./1.5-templui-integration.md)

## Overview

Implement the core middleware stack for generated applications and create comprehensive documentation for Phase 1 features. This epic establishes essential middleware for request ID generation, logging, recovery, compression, security headers, and static file serving. It also creates detailed guides for router setup, template development, middleware configuration, asset management, and templ-ui customization.

## Goals

- Request ID generation middleware
- Structured logging middleware (zerolog)
- Panic recovery middleware
- Compression middleware (gzip)
- Security headers middleware
- Static file serving middleware
- CORS middleware (for API endpoints)
- Rate limiting middleware (basic)
- Middleware ordering documentation
- Complete router setup guide
- Template component guide
- Asset management guide
- Templ-UI customization guide
- Troubleshooting documentation

## Scope

### In Scope

- Request ID middleware (chi built-in)
- Logging middleware with zerolog
- Recovery middleware
- Compression middleware (chi built-in)
- Security headers (X-Content-Type-Options, X-Frame-Options, etc.)
- Static file serving
- CORS middleware
- Basic rate limiting
- Middleware order documentation
- Router setup documentation
- Template development documentation
- Asset pipeline documentation
- Component customization documentation
- Troubleshooting guides

### Out of Scope

- Authentication middleware (Phase 3)
- Authorization/RBAC middleware (Phase 3)
- CSRF protection (Phase 3)
- Session management (Phase 3)
- Advanced rate limiting (distributed, Redis-based)
- WAF-style request filtering (future)
- API versioning middleware (future)

## Task Breakdown

The following tasks will become GitHub issues, ordered by dependency:

### Phase 1: Core Middleware (Tasks 1-15)

1. **Create middleware package (internal/http/middleware/)**
   - Package structure
   - Helper functions
   - Documentation

2. **Implement RequestID middleware**
   - Use chi.RequestID
   - Attach to context
   - Log with requests

3. **Create logging middleware with zerolog**
   - Log all requests
   - Include request ID, method, path, status, duration
   - Configurable log level

4. **Implement recovery middleware**
   - Catch panics
   - Log stack traces
   - Return 500 error page
   - Continue serving other requests

5. **Add compression middleware**
   - Use chi.Compress
   - gzip compression
   - Configure compression level

6. **Create security headers middleware**
   - X-Content-Type-Options: nosniff
   - X-Frame-Options: DENY
   - X-XSS-Protection: 1; mode=block
   - Referrer-Policy: strict-origin-when-cross-origin
   - Configurable via environment

7. **Implement CORS middleware**
   - Configurable allowed origins
   - Preflight request handling
   - Credentials support
   - Document CORS configuration

8. **Create rate limiting middleware (basic)**
   - In-memory rate limiter
   - Per-IP limiting
   - Configurable requests per window
   - Return 429 Too Many Requests

9. **Add timeout middleware**
   - Use chi.Timeout
   - Configurable timeout duration
   - Return 504 Gateway Timeout

10. **Create real IP middleware**
    - Extract real IP from X-Forwarded-For
    - Handle proxy headers
    - Configurable trusted proxies

11. **Implement content security policy (CSP) middleware**
    - Nonce generation for scripts
    - Strict CSP by default
    - Configurable policy

12. **Add allowed hosts middleware**
    - Prevent host header attacks
    - Configurable allowed hosts
    - Return 400 Bad Request for invalid hosts

13. **Create middleware chain builder**
    - Compose middlewares easily
    - Default production chain
    - Default development chain

14. **Test all middleware**
    - Unit tests for each middleware
    - Integration tests for middleware chain
    - Verify headers set correctly

15. **Document middleware chain ordering**
    - Explain why order matters
    - Show correct ordering
    - Common mistakes

### Phase 2: Middleware Integration (Tasks 16-25)

1. **Register middlewares in server.go**
    - Apply global middlewares
    - Apply route-specific middlewares
    - Document middleware registration

2. **Create middleware configuration**
    - Environment variables for middleware
    - Viper integration
    - Default values

3. **Add middleware toggle flags**
    - Enable/disable specific middlewares
    - Development vs production
    - Document configuration

4. **Implement middleware metrics**
    - Track request count
    - Track response times
    - Expose via /metrics endpoint (future)

5. **Create custom middleware example**
    - Show how to write custom middleware
    - Document middleware signature
    - Best practices

6. **Add middleware tests to generated projects**
    - Test middleware in isolation
    - Test middleware chain
    - Document testing patterns

7. **Create middleware troubleshooting guide**
    - Common issues (order, configuration)
    - Debugging middleware
    - Performance considerations

8. **Document middleware best practices**
    - When to use middleware vs handlers
    - Stateful vs stateless middleware
    - Error handling

9. **Add middleware examples to README**
    - Show common patterns
    - Link to detailed docs
    - Quick reference

10. **Create middleware security checklist**
    - Required security headers
    - CORS configuration
    - CSP policy
    - Rate limiting

### Phase 3: Router Documentation (Tasks 26-35)

1. **Write router setup guide**
    - Server structure explanation
    - Builder pattern for DI
    - Route registration

2. **Document route constants pattern**
    - Why use constants
    - Route helper functions
    - templ.SafeURL helpers

3. **Create route organization guide**
    - Grouping routes
    - Route nesting
    - Subroutes

4. **Document hypermedia routing patterns**
    - GET (forms) vs POST (actions)
    - Slug-based URLs
    - Route helper usage

5. **Create route testing guide**
    - Testing route registration
    - Testing handlers
    - Integration tests

6. **Document graceful shutdown**
    - Signal handling
    - In-flight request handling
    - Timeout configuration

7. **Create HTTP configuration guide**
    - Server timeouts
    - Max header bytes
    - TLS setup

8. **Document health check endpoint**
    - Purpose and usage
    - Kubernetes integration
    - Monitoring setup

9. **Create router troubleshooting guide**
    - Route conflicts
    - Middleware issues
    - 404 debugging

10. **Write router best practices**
    - RESTful patterns
    - Hypermedia patterns
    - Performance tips

### Phase 4: Template Documentation (Tasks 36-45)

1. **Write template development guide**
    - Templ syntax reference
    - Component creation
    - Props patterns

2. **Document layout composition**
    - Base layout
    - Nested layouts
    - Slot-based content

3. **Create component library guide**
    - Organizing components
    - Reusable patterns
    - Documentation

4. **Document helper functions**
    - ClassNames helper
    - SafeHTML helper
    - HTMX attribute helpers

5. **Create form handling guide**
    - Form components
    - Validation display
    - HTMX integration

6. **Document error page templates**
    - 404, 500, 403 pages
    - Custom error pages
    - Error context

7. **Write template testing guide**
    - Rendering tests
    - Props validation
    - Integration tests

8. **Create template performance guide**
    - Compilation optimization
    - Rendering performance
    - Caching strategies

9. **Document dark mode implementation**
    - Theme toggler
    - CSS custom properties
    - Component variants

10. **Write template best practices**
    - Component composition
    - Props design
    - Accessibility

### Phase 5: Asset & Build Documentation (Tasks 46-55)

1. **Write asset pipeline guide**
    - HashFS overview
    - Content hashing
    - Cache strategy

2. **Document asset helper functions**
    - AssetURL helper
    - CSS, JS, Image helpers
    - Preload helpers

3. **Create TailwindCSS configuration guide**
    - Tailwind config
    - JIT mode
    - Custom theme

4. **Document JavaScript bundling**
    - esbuild configuration
    - Alpine.js integration
    - Source maps

5. **Write Air configuration guide**
    - Live reload setup
    - File watching
    - Build sequence

6. **Create Makefile reference**
    - All make targets
    - Usage examples
    - Common workflows

7. **Document build modes**
    - Development builds
    - Production builds
    - Environment variables

8. **Write asset optimization guide**
    - Image optimization
    - CSS minification
    - JS minification

9. **Create build troubleshooting guide**
    - Common build errors
    - Air issues
    - Cache problems

10. **Document build best practices**
    - Asset organization
    - Bundle size optimization
    - Performance tips

### Phase 6: Comprehensive Documentation (Tasks 56-70)

1. **Create quickstart guide**
    - Installation
    - First project
    - Basic customization

2. **Write development workflow guide**
    - Local development
    - Live reload
    - Debugging

3. **Create deployment guide**
    - Building for production
    - Environment configuration
    - Docker setup (basic)

4. **Document project structure**
    - Directory layout
    - File organization
    - Naming conventions

5. **Write configuration reference**
    - Environment variables
    - .env file
    - Viper usage

6. **Create templ-ui customization guide**
    - Component ownership
    - Modification workflow
    - Update strategy

7. **Document CLI commands**
    - tracks new
    - tracks ui
    - tracks db (future)

8. **Write testing guide**
    - Unit tests
    - Integration tests
    - E2E tests (basic)

9. **Create security guide**
    - Security headers
    - CSP policy
    - HTTPS setup

10. **Document logging and monitoring**
    - Structured logging
    - Request IDs
    - Metrics (future)

11. **Write database integration guide (placeholder)**
    - SQLC overview
    - Migration workflow
    - Repository pattern

12. **Create FAQ document**
    - Common questions
    - Troubleshooting
    - Best practices

13. **Write contributing guide for generated projects**
    - Code style
    - PR process
    - Testing requirements

14. **Create example application**
    - Full-featured demo app
    - Show all features
    - Commented code

15. **Write Phase 1 completion checklist**
    - Feature verification
    - Testing requirements
    - Documentation completeness

## Dependencies

### Prerequisites

- Phase 0 completed
- Epic 1.1 completed (Chi router)
- Epic 1.2 completed (Templ templates)
- Epic 1.3 completed (HashFS assets)
- Epic 1.4 completed (Web build pipeline)
- Epic 1.5 completed (Templ-UI integration)

### External Dependencies

- `github.com/rs/zerolog` - Structured logging
- `github.com/go-chi/chi/v5/middleware` - Chi built-in middleware
- `github.com/go-chi/cors` - CORS middleware (optional)

## Acceptance Criteria

### Middleware Implementation

- [ ] Request ID middleware functional
- [ ] Logging middleware logs all requests
- [ ] Recovery middleware catches panics
- [ ] Compression middleware enabled
- [ ] Security headers set correctly
- [ ] CORS middleware configurable
- [ ] Rate limiting middleware working
- [ ] Middleware chain documented

### Documentation

- [ ] Router setup guide complete
- [ ] Template development guide complete
- [ ] Asset pipeline guide complete
- [ ] Middleware guide complete
- [ ] Templ-UI customization guide complete
- [ ] Build workflow documented
- [ ] Troubleshooting guides created
- [ ] Example application working

### Testing

- [ ] All middleware unit tests pass
- [ ] Integration tests verify middleware chain
- [ ] Documentation examples verified
- [ ] Example application builds and runs

## Technical Notes

### Middleware Chain Order

**Critical:** Middleware order matters! Apply in this sequence:

```go
// internal/http/routes.go

func (s *Server) routes() {
    // 1. Request ID (first - needed by logging)
    s.router.Use(middleware.RequestID)

    // 2. Real IP (before logging)
    s.router.Use(middleware.RealIP)

    // 3. Logging (early - log all requests)
    s.router.Use(middlewares.Logger(s.logger))

    // 4. Recovery (catch panics)
    s.router.Use(middleware.Recoverer)

    // 5. Compression (before content sent)
    s.router.Use(middleware.Compress(5))

    // 6. Security headers
    s.router.Use(middlewares.SecurityHeaders)

    // 7. Timeout (wrap request handling)
    s.router.Use(middleware.Timeout(60 * time.Second))

    // 8. Rate limiting (after logging, before handlers)
    s.router.Use(middlewares.RateLimit)

    // Routes...
}
```

### Logging Middleware

```go
// internal/http/middleware/logger.go
package middleware

import (
    "net/http"
    "time"
    "github.com/go-chi/chi/v5/middleware"
    "github.com/rs/zerolog"
)

func Logger(log zerolog.Logger) func(next http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()

            // Wrap response writer to capture status
            ww := middleware.NewWrapResponseWriter(w, r.ProtoMajor)

            // Get request ID from context
            requestID := middleware.GetReqID(r.Context())

            // Call next handler
            next.ServeHTTP(ww, r)

            // Log request
            log.Info().
                Str("request_id", requestID).
                Str("method", r.Method).
                Str("path", r.URL.Path).
                Int("status", ww.Status()).
                Int("bytes", ww.BytesWritten()).
                Dur("duration_ms", time.Since(start)).
                Str("remote_addr", r.RemoteAddr).
                Str("user_agent", r.UserAgent()).
                Msg("request completed")
        })
    }
}
```

### Recovery Middleware

```go
// internal/http/middleware/recovery.go
package middleware

import (
    "net/http"
    "runtime/debug"
    "github.com/rs/zerolog"
    "myapp/internal/http/views/pages"
)

func Recovery(log zerolog.Logger) func(next http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            defer func() {
                if err := recover(); err != nil {
                    // Log panic with stack trace
                    log.Error().
                        Interface("error", err).
                        Str("stack", string(debug.Stack())).
                        Msg("panic recovered")

                    // Render error page
                    w.WriteHeader(http.StatusInternalServerError)
                    component := pages.ErrorPage(pages.ErrorPageProps{
                        Code:    500,
                        Title:   "Internal Server Error",
                        Message: "Something went wrong. We're working on it.",
                    })
                    component.Render(r.Context(), w)
                }
            }()

            next.ServeHTTP(w, r)
        })
    }
}
```

### Security Headers Middleware

```go
// internal/http/middleware/security_headers.go
package middleware

import "net/http"

func SecurityHeaders(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Prevent MIME type sniffing
        w.Header().Set("X-Content-Type-Options", "nosniff")

        // Prevent clickjacking
        w.Header().Set("X-Frame-Options", "DENY")

        // Enable XSS protection
        w.Header().Set("X-XSS-Protection", "1; mode=block")

        // Referrer policy
        w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")

        // Content Security Policy
        // Adjust based on your needs
        csp := "default-src 'self'; " +
            "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com; " +
            "style-src 'self' 'unsafe-inline'; " +
            "img-src 'self' data:; " +
            "font-src 'self'; " +
            "connect-src 'self';"
        w.Header().Set("Content-Security-Policy", csp)

        next.ServeHTTP(w, r)
    })
}
```

### Rate Limiting Middleware (Basic)

```go
// internal/http/middleware/rate_limit.go
package middleware

import (
    "net/http"
    "sync"
    "time"
    "golang.org/x/time/rate"
)

type IPRateLimiter struct {
    ips map[string]*rate.Limiter
    mu  sync.RWMutex
    r   rate.Limit
    b   int
}

func NewIPRateLimiter(r rate.Limit, b int) *IPRateLimiter {
    return &IPRateLimiter{
        ips: make(map[string]*rate.Limiter),
        r:   r,
        b:   b,
    }
}

func (i *IPRateLimiter) GetLimiter(ip string) *rate.Limiter {
    i.mu.Lock()
    defer i.mu.Unlock()

    limiter, exists := i.ips[ip]
    if !exists {
        limiter = rate.NewLimiter(i.r, i.b)
        i.ips[ip] = limiter
    }

    return limiter
}

func RateLimit(next http.Handler) http.Handler {
    // 10 requests per second, burst of 20
    limiter := NewIPRateLimiter(10, 20)

    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        ip := r.RemoteAddr
        if !limiter.GetLimiter(ip).Allow() {
            http.Error(w, "Too Many Requests", http.StatusTooManyRequests)
            return
        }

        next.ServeHTTP(w, r)
    })
}
```

### CORS Middleware

```go
// internal/http/middleware/cors.go
package middleware

import (
    "net/http"
    "strings"
)

func CORS(allowedOrigins []string) func(next http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            origin := r.Header.Get("Origin")

            // Check if origin is allowed
            allowed := false
            for _, ao := range allowedOrigins {
                if ao == "*" || ao == origin {
                    allowed = true
                    break
                }
            }

            if allowed {
                w.Header().Set("Access-Control-Allow-Origin", origin)
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                w.Header().Set("Access-Control-Allow-Credentials", "true")
            }

            // Handle preflight
            if r.Method == "OPTIONS" {
                w.WriteHeader(http.StatusNoContent)
                return
            }

            next.ServeHTTP(w, r)
        })
    }
}
```

### Middleware Configuration

```go
// .env.example

# Middleware Configuration
APP_CORS_ALLOWED_ORIGINS=http://localhost:3000,https://example.com
APP_RATE_LIMIT_ENABLED=true
APP_RATE_LIMIT_REQUESTS_PER_SECOND=10
APP_RATE_LIMIT_BURST=20
APP_REQUEST_TIMEOUT=60s
```

### README Example

```markdown
# MyApp

Generated with Tracks - a code-generating web framework for Go.

## Quick Start

```bash
# Copy environment template
cp .env.example .env

# Run development server with live reload
make dev

# Visit http://localhost:8080
```

## Features

- ✅ Chi router with middleware
- ✅ Templ type-safe templates
- ✅ TailwindCSS with JIT mode
- ✅ Alpine.js for interactivity
- ✅ Templ-UI component library
- ✅ HashFS for asset serving
- ✅ Live reload with Air

## Development

```bash
# Run all generators (sqlc, templ, mockery)
make generate

# Build frontend assets (CSS, JavaScript)
make assets

# Run tests
make test

# Run linters
make lint

# Build production binary
make build
```

## Project Structure

```text
myapp/
├── cmd/server/         # Server entry point
├── internal/
│   ├── http/           # HTTP layer
│   │   ├── server.go   # Server setup
│   │   ├── routes.go   # Route registration
│   │   ├── handlers/   # HTTP handlers
│   │   ├── middleware/ # Custom middleware
│   │   └── views/      # Templ templates
│   ├── assets/         # Embedded assets
│   └── domain/         # Business logic (future)
├── web/                # Frontend source
│   ├── css/            # Stylesheets
│   ├── js/             # JavaScript
│   └── images/         # Images
├── .air.toml           # Live reload config
├── tailwind.config.js  # Tailwind config
├── templui.yaml        # Templ-UI config
├── Makefile            # Build commands
└── README.md           # This file
```

## Documentation

See `docs/` directory for:

- Router setup guide
- Template development
- Component customization
- Asset management
- Deployment guide

## License

[Your license here]

## Testing Strategy

### Middleware Tests

- Test each middleware in isolation
- Test middleware chain order
- Verify headers set correctly
- Test error cases (panics, timeouts)

### Documentation Tests

- Verify all code examples compile
- Test example application
- Check links in documentation
- Verify completeness

### Integration Tests

- Full request lifecycle
- Middleware chain behavior
- Error handling
- Performance

## Next Steps

Phase 1 is complete! Next phase will add:

- Database integration (SQLC, migrations)
- Repository pattern
- Service layer
- Domain logic

See [Phase 2: Data Layer →](../../2-data-layer.md)
