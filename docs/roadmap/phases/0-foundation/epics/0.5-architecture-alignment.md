# Epic 0.5: Architecture Alignment (URGENT)

[← Back to Phase 0](../0-foundation.md) | [← Epic 2](./2-template-engine.md) | [Epic 3 →](./3-project-generation.md)

## ⚠️ STOP-THE-LINE EPIC

This epic **supercedes all other work** until complete. We identified critical architectural issues that will block Epic 3 Phase 3+ and create significant technical debt if not addressed immediately.

## Overview

Align the CLI codebase with the clean architecture principles we defined for generated servers. The CLI tool should be exemplary code since it generates exemplary code. Currently, we have architectural inconsistencies that violate our own best practices.

## Why Now (Not Later)

**Blocking Issues for Epic 3 Phase 3:**

- Import cycles will prevent `tracks new` from using the validator
- Interface definitions in wrong packages prevent proper testing
- No dependency injection pattern makes commands untestable
- Documentation contradictions will confuse future development

**Cost Analysis:**

- Fix now: ~2 days before Epic 3 Phase 3
- Fix later: ~5 days + rework of Epic 3 Phases 3-8 + broken promises

**Decision:** Fix now, prevent compounding debt.

## Goals

1. **Zero Import Cycles** - Clean dependency graph
2. **Interface-First Design** - Interfaces in consumer packages
3. **Dependency Injection** - Testable, composable commands
4. **Documentation Accuracy** - CLAUDE.md matches reality
5. **Architectural Tests** - Prevent regression

## Critical Issues Found

### 1. Documentation vs Reality: Logging (CRITICAL)

**CLAUDE.md says:**
> NO structured logging - CLI uses human-friendly output, not zerolog

**Reality:** We just added `internal/cli/logger.go` with zerolog in PR #152

**Impact:** Direct contradiction confuses development

**Fix:** Update CLAUDE.md to document dual-output strategy:

- Renderer for user-facing output (stdout)
- zerolog for developer logging (stderr, controlled by TRACKS_LOG_LEVEL)

### 2. Interface Definition Anti-Pattern (CRITICAL)

**Problem:** ALL interfaces defined by providers, not consumers

**Violations Found:**

1. `Validator` interface in `internal/generator/validator.go` (provider)
2. `ProjectGenerator` interface in `internal/generator/generator.go` (provider)
3. `Renderer` interface in `internal/cli/renderer/renderer.go` (provider)
4. `Progress` interface in `internal/cli/renderer/types.go` (provider)
5. `template.Renderer` interface in `internal/generator/template/renderer.go` (provider)

```go
// ❌ WRONG: Provider defines interface
// internal/generator/validator.go
type Validator interface { ... }

// ❌ WRONG: CLI imports generator to use interface
// internal/cli/commands/new.go (future)
import "github.com/anomalousventures/tracks/internal/generator"
```

**Fix:** Consumer defines interface

```go
// ✅ CORRECT: Consumer defines interface
// internal/cli/interfaces/validator.go
type Validator interface { ... }

// ✅ CORRECT: Generator implements consumer's interface
// internal/generator/validator_impl.go
type validatorImpl struct { ... }
func (v *validatorImpl) ValidateProjectName(...) { ... }
```

### 3. Validator Import Cycle (CRITICAL)

**Current:**

```text
internal/generator/validator_impl.go imports internal/cli (for logger)
internal/cli will import internal/generator (for Validator interface - Phase 3)
= IMPORT CYCLE (will break in Phase 3)
```

**Fix:** Pass logger as dependency, don't import cli package

### 4. No Dependency Injection Pattern (CRITICAL)

**Current:**

```go
// ❌ Direct instantiation, untestable
func newCmd() *cobra.Command {
    return &cobra.Command{
        Run: func(cmd *cobra.Command, args []string) {
            validator := generator.NewValidator()  // Hard-coded dependency
            // Can't mock, can't test
        },
    }
}
```

**Fix:**

```go
// ✅ Dependency injection, testable
type NewCommand struct {
    validator interfaces.Validator
    generator interfaces.ProjectGenerator
}

func NewNewCommand(v interfaces.Validator, g interfaces.ProjectGenerator) *NewCommand {
    return &NewCommand{validator: v, generator: g}
}
```

### 5. Command Structure Missing (CRITICAL)

**CLAUDE.md says:**
> **Key Files:**
>
> - `internal/cli/commands/` - Cobra command definitions

**Reality:**

- No `commands/` directory
- All commands inline in `root.go` (will become 1000+ lines)

**Fix:** Create command structure before Phase 3

## Scope

### In Scope

- Fix all 5 critical issues
- Establish dependency injection pattern
- Restructure packages for clarity
- Context propagation pattern
- Update all documentation
- Create architectural tests

### Out of Scope

- Feature work (Epic 3 Phase 3+ blocked until this completes)
- Minor refactoring (naming conventions, etc.)
- Generated server changes
- Performance optimization

## Task Breakdown

### Phase 1: Critical Fixes (Sequential - Must Complete First)

These tasks block all other work. Must be completed in order.

1. **Create commands/ directory structure** (#155)
2. **Move newCmd to internal/cli/commands/new.go** (#156)
3. **Move versionCmd to internal/cli/commands/version.go** (#157)
4. **Create internal/cli/interfaces/ directory** (#158)
5. **Move Validator interface to internal/cli/interfaces/validator.go** (#159)
6. **Move ProjectGenerator interface to internal/cli/interfaces/generator.go** (#160)
7. **Move Renderer interface to internal/cli/interfaces/renderer.go** (#190)
8. **Move Progress interface to internal/cli/interfaces/renderer.go** (#191)
9. **Create internal/generator/interfaces/ directory** (#192)
10. **Move template.Renderer to internal/generator/interfaces/template_renderer.go** (#193)
11. **Fix validator → cli import: pass logger as constructor param** (#161)
12. **Write unit tests for interface moves** (#162)

### Phase 2: Dependency Injection Pattern (Can Start After Phase 1)

Establish the pattern we'll use throughout.

1. **Create NewCommand struct with DI fields** (#163)
2. **Implement NewNewCommand constructor** (#164)
3. **Create VersionCommand struct with DI** (#165)
4. **Update root.go to use command factories** (#166)
5. **Write unit tests for NewCommand** (#167)
6. **Write unit tests for VersionCommand** (#168)

### Phase 3: Package Restructuring (Can Parallelize with Phase 2)

Clean separation of concerns.

1. **Create internal/validation/ package** (#169)
2. **Move validator implementation to internal/validation/** (#170)
3. **Update imports across codebase** (#171)
4. **Write tests for validation package** (#172)

### Phase 4: Context Propagation (After Phase 2)

Consistent pattern for request-scoped values.

1. **Establish context propagation pattern** (#173)
2. **Attach logger to context in root** (#174)
3. **Update command signatures to receive context** (#175)
4. **Write tests for context propagation** (#176)

### Phase 5: Documentation Updates (After Phase 4)

Make documentation match reality.

1. **Update CLAUDE.md CLI architecture section** (#177)
2. **Update Epic 3 to reflect new structure** (#178)
3. **Update Epic 1 (completed work) for accuracy** (#179)
4. **Create architecture decision records** (#180)

### Phase 6: Architecture Tests (After Phase 5)

Prevent regression.

1. **Add import cycle detection test** (#181)
2. **Add interface location validation test** (#182)
3. **Add DI pattern enforcement test** (#183)
4. **Document architecture test strategy** (#184)

## Dependencies

### Prerequisites

- Epic 1 (CLI Infrastructure) - Complete ✅
- Epic 2 (Template Engine) - Complete ✅
- Epic 3 Phase 1 (Interfaces & Types) - Complete ✅
- Epic 3 Phase 2 (Validation Logic) - Complete ✅

### Blocks

- **Epic 3 Phase 3** (Command Implementation) - BLOCKED until Epic 0.5 complete
- **Epic 3 Phase 4+** (File Generation) - BLOCKED
- All future CLI work

## Acceptance Criteria

### Structural

- [ ] `internal/cli/commands/` directory exists
- [ ] `internal/cli/interfaces/` directory exists
- [ ] `internal/generator/interfaces/` directory exists
- [ ] `internal/validation/` package exists
- [ ] ALL 5 interfaces in consumer packages (Validator, ProjectGenerator, Renderer, Progress, template.Renderer)
- [ ] All commands use DI pattern
- [ ] No import cycles detected

### Testing

- [ ] `make lint` passes
- [ ] `make test` passes
- [ ] All new code has >90% test coverage
- [ ] Architecture tests enforce patterns

### Documentation

- [ ] CLAUDE.md CLI section accurate
- [ ] Epic 3 updated with new structure
- [ ] All code examples show DI pattern
- [ ] Architecture Decision Records created

### Quality

- [ ] Zero `go vet` warnings
- [ ] Zero `golangci-lint` errors
- [ ] All commands testable in isolation
- [ ] Context propagated consistently

## Technical Notes

### New Directory Structure

```text
internal/
├── cli/
│   ├── commands/
│   │   ├── new.go           # NewCommand struct + constructor
│   │   └── version.go       # VersionCommand struct + constructor
│   ├── interfaces/
│   │   ├── generator.go     # ProjectGenerator interface
│   │   └── validator.go     # Validator interface
│   ├── renderer/            # Existing
│   ├── ui/                  # Existing
│   ├── logger.go            # Existing
│   └── root.go              # Simplified (just setup + factories)
├── generator/
│   ├── generator.go         # Generator interface (will move to cli/interfaces)
│   ├── generator_impl.go    # Implementation (future)
│   ├── config.go            # Existing
│   ├── errors.go            # Existing
│   └── template/            # Existing
└── validation/
    ├── validator.go         # Validator implementation (moved from generator/)
    └── rules.go             # Validation rules (extracted)
```

### Dependency Injection Pattern

**Command Structure:**

```go
// internal/cli/commands/new.go
package commands

import (
    "context"
    "github.com/anomalousventures/tracks/internal/cli/interfaces"
    "github.com/spf13/cobra"
)

type NewCommand struct {
    validator interfaces.Validator
    generator interfaces.ProjectGenerator
}

func NewNewCommand(v interfaces.Validator, g interfaces.ProjectGenerator) *NewCommand {
    return &NewCommand{
        validator: v,
        generator: g,
    }
}

func (c *NewCommand) Command() *cobra.Command {
    return &cobra.Command{
        Use:   "new [project-name]",
        Short: "Create a new Tracks application",
        Args:  cobra.ExactArgs(1),
        RunE:  c.run,
    }
}

func (c *NewCommand) run(cmd *cobra.Command, args []string) error {
    ctx := cmd.Context()
    projectName := args[0]

    // Use injected dependencies
    if err := c.validator.ValidateProjectName(projectName); err != nil {
        return err
    }

    // ... rest of implementation
    return nil
}
```

**Root Setup:**

```go
// internal/cli/root.go
func NewRootCmd(build BuildInfo) *cobra.Command {
    // ... root cmd setup

    // Wire up dependencies
    logger := cli.NewLogger("off")
    validator := validation.NewValidator(logger)  // Pass logger explicitly
    generator := generator.NewGenerator()

    // Create commands with DI
    newCommand := commands.NewNewCommand(validator, generator)
    versionCommand := commands.NewVersionCommand(build)

    // Add subcommands
    rootCmd.AddCommand(newCommand.Command())
    rootCmd.AddCommand(versionCommand.Command())

    return rootCmd
}
```

### Interface Placement Rules

**Rule 1:** Interfaces belong in the package that uses them (consumer)

```go
// ✅ CORRECT
internal/cli/interfaces/validator.go  // CLI uses validator, owns interface
internal/validation/validator.go      // Implementation

// ❌ WRONG
internal/validation/validator.go      // Both interface and impl together
```

**Rule 2:** Avoid `interfaces` package if only one consumer

```go
// ✅ BETTER (if only NewCommand uses Validator)
internal/cli/commands/interfaces.go   // In commands package

// ⚠️ ACCEPTABLE (if multiple commands use it)
internal/cli/interfaces/validator.go  // Shared interfaces
```

**Rule 3:** Use descriptive names (not just "Interface")

```go
// ✅ GOOD
type Validator interface { ... }
type ProjectGenerator interface { ... }

// ❌ BAD
type ValidatorInterface interface { ... }
type IValidator interface { ... }
```

### Context Propagation

**Pattern:**

```go
// Attach logger in root
ctx := context.Background()
ctx = WithLogger(ctx, logger)
cmd.SetContext(ctx)

// Retrieve in command
func (c *NewCommand) run(cmd *cobra.Command, args []string) error {
    logger := GetLogger(cmd.Context())
    logger.Debug().Str("project", args[0]).Msg("creating project")
    // ...
}
```

**Rules:**

- Always pass `context.Context` as first parameter
- Never store context in struct fields
- Attach request-scoped values only (logger, tracing, etc.)

### Validation Package

**Responsibility:** Validate inputs (project names, paths, drivers)

**Does NOT:**

- Generate projects (that's generator package)
- Render templates (that's generator/template)
- Parse CLI flags (that's commands package)

**Clean separation:**

```go
// internal/validation/validator.go
package validation

import "github.com/rs/zerolog"

type Validator struct {
    logger zerolog.Logger  // Passed via constructor, not imported
}

func NewValidator(logger zerolog.Logger) *Validator {
    return &Validator{logger: logger}
}

func (v *Validator) ValidateProjectName(name string) error {
    // Validation logic
    if err != nil {
        v.logger.Warn().Str("name", name).Msg("invalid project name")
        return err
    }
    return nil
}
```

## Testing Strategy

### Unit Tests

Every new file must have corresponding `_test.go`:

- `internal/cli/commands/new_test.go` - Test NewCommand with mocks
- `internal/cli/commands/version_test.go` - Test VersionCommand
- `internal/validation/validator_test.go` - Test validation logic
- `internal/cli/interfaces/` - No tests (just interfaces)

### Architecture Tests

Enforce patterns programmatically:

```go
// internal/cli/commands/architecture_test.go
package commands

import (
    "go/ast"
    "go/parser"
    "go/token"
    "os/exec"
    "path/filepath"
    "strings"
    "testing"
)

func TestNoImportCycles(t *testing.T) {
    // Use go list to detect import cycles
    cmd := exec.Command("go", "list", "-json", "./...")
    output, err := cmd.CombinedOutput()
    if err != nil {
        // go list returns error if cycles detected
        if strings.Contains(string(output), "import cycle") {
            t.Fatalf("Import cycle detected:\n%s", output)
        }
    }
}

func TestInterfacesInConsumerPackages(t *testing.T) {
    // Verify cli/interfaces only contains interface definitions
    interfacesPath := filepath.Join("internal", "cli", "interfaces")
    fset := token.NewFileSet()

    pkgs, err := parser.ParseDir(fset, interfacesPath, nil, 0)
    if err != nil {
        t.Fatalf("Failed to parse interfaces package: %v", err)
    }

    for _, pkg := range pkgs {
        for _, file := range pkg.Files {
            ast.Inspect(file, func(n ast.Node) bool {
                // Check for struct types (should only have interfaces)
                if ts, ok := n.(*ast.TypeSpec); ok {
                    if _, isStruct := ts.Type.(*ast.StructType); isStruct {
                        t.Errorf("Found struct type %s in interfaces package", ts.Name.Name)
                    }
                }
                return true
            })
        }
    }
}

func TestCommandsUseDI(t *testing.T) {
    // Verify all Command structs have New* constructor functions
    commandsPath := filepath.Join("internal", "cli", "commands")
    fset := token.NewFileSet()

    pkgs, err := parser.ParseDir(fset, commandsPath, nil, 0)
    if err != nil {
        t.Fatalf("Failed to parse commands package: %v", err)
    }

    commandStructs := make(map[string]bool)
    constructors := make(map[string]bool)

    for _, pkg := range pkgs {
        for _, file := range pkg.Files {
            ast.Inspect(file, func(n ast.Node) bool {
                // Find Command structs
                if ts, ok := n.(*ast.TypeSpec); ok {
                    if strings.HasSuffix(ts.Name.Name, "Command") {
                        commandStructs[ts.Name.Name] = true
                    }
                }
                // Find New* constructors
                if fd, ok := n.(*ast.FuncDecl); ok {
                    if strings.HasPrefix(fd.Name.Name, "New") &&
                       strings.HasSuffix(fd.Name.Name, "Command") {
                        constructors[fd.Name.Name] = true
                    }
                }
                return true
            })
        }
    }

    // Verify each Command struct has a corresponding New* constructor
    for cmd := range commandStructs {
        expectedConstructor := "New" + cmd
        if !constructors[expectedConstructor] {
            t.Errorf("Command struct %s missing constructor %s", cmd, expectedConstructor)
        }
    }
}
```

### Integration Tests

After Epic 0.5 complete, verify:

- `tracks version` still works
- `tracks new myapp` stub still works
- All flags work (--json, --no-color, etc.)

## Migration Path

### For Each Command

1. Create `internal/cli/commands/<command>.go`
2. Define `<Command>Command struct`
3. Add constructor `New<Command>Command(...)`
4. Implement `Command() *cobra.Command`
5. Move logic to `run(cmd, args) error`
6. Write tests with mocked dependencies
7. Update `root.go` to use factory

### For Each Interface

1. Identify consumers (who uses this?)
2. Create interface in consumer package
3. Update provider to implement interface
4. Update imports
5. Remove old interface definition
6. Run tests

## Rollout Plan

### Phase 1: Day 1 Morning (4 hours)

- Create directory structure
- Move commands to separate files
- Move interfaces to cli package
- Fix validator import cycle

**Checkpoint:** No import cycles, structure in place

### Phase 2: Day 1 Afternoon (3 hours)

- Establish DI pattern
- Refactor NewCommand
- Refactor VersionCommand
- Update root.go

**Checkpoint:** Commands use DI, tests pass

### Phase 3: Day 2 Morning (3 hours)

- Create validation package
- Move validator implementation
- Update imports
- Fix tests

**Checkpoint:** Clean package separation

### Phase 4: Day 2 Afternoon (2 hours)

- Context propagation
- Documentation updates
- Architecture tests

**Checkpoint:** Epic 0.5 complete, ready for Epic 3 Phase 3

## Success Metrics

- **Architectural:** Zero import cycles, all interfaces in consumer packages
- **Testing:** 100% of new code has tests, architecture tests prevent regression
- **Documentation:** CLAUDE.md accurate, Epic 3 updated, ADRs created
- **Velocity:** Epic 3 Phase 3 can start immediately after completion

## Risks & Mitigation

### Risk: Breaking Existing Functionality

**Mitigation:**

- Keep integration tests green throughout
- Make small, incremental changes
- Test after each phase

### Risk: Delays Epic 3 Delivery

**Mitigation:**

- This IS Epic 3 work (preventing future rework)
- 2 days now vs 5+ days later
- Faster Epic 3 Phase 3+ after this complete

### Risk: Incomplete Architecture

**Mitigation:**

- Architecture tests enforce patterns
- Code reviews focus on architecture
- ADRs document decisions

## Next Epic

After Epic 0.5 complete:

[Epic 3 Phase 3: Command Implementation →](./3-project-generation.md#phase-3-command-implementation)

---

**Status:** 🔴 NOT STARTED (Blocking Epic 3 Phase 3)

**Estimated Completion:** 2 days (16 hours)

**Priority:** 🚨 CRITICAL - Stop all other work
