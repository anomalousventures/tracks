# Epic 0.5: Architecture Alignment (URGENT)

[â† Back to Phase 0](../0-foundation.md) | [â† Epic 2](./2-template-engine.md) | [Epic 3 â†’](./3-project-generation.md)

## âš ï¸ STOP-THE-LINE EPIC

This epic **supercedes all other work** until complete. We identified critical architectural issues that will block Epic 3 Phase 3+ and create significant technical debt if not addressed immediately.

## Overview

Align the CLI codebase with the clean architecture principles we defined for generated servers. The CLI tool should be exemplary code since it generates exemplary code. Currently, we have architectural inconsistencies that violate our own best practices.

## Why Now (Not Later)

**Blocking Issues for Epic 3 Phase 3:**

- Import cycles will prevent `tracks new` from using the validator
- Interface definitions in wrong packages prevent proper testing
- No dependency injection pattern makes commands untestable
- Documentation contradictions will confuse future development

**Cost Analysis:**

- Fix now: ~2 days before Epic 3 Phase 3
- Fix later: ~5 days + rework of Epic 3 Phases 3-8 + broken promises

**Decision:** Fix now, prevent compounding debt.

## Goals

1. **Zero Import Cycles** - Clean dependency graph
2. **Interface-First Design** - Interfaces in consumer packages
3. **Dependency Injection** - Testable, composable commands
4. **Documentation Accuracy** - CLAUDE.md matches reality
5. **Architectural Tests** - Prevent regression

## Critical Issues Found

### 1. Documentation vs Reality: Logging (CRITICAL)

**CLAUDE.md says:**
> NO structured logging - CLI uses human-friendly output, not zerolog

**Reality:** We just added `internal/cli/logger.go` with zerolog in PR #152

**Impact:** Direct contradiction confuses development

**Fix:** Update CLAUDE.md to document dual-output strategy:

- Renderer for user-facing output (stdout)
- zerolog for developer logging (stderr, controlled by TRACKS_LOG_LEVEL)

### 2. Interface Definition Anti-Pattern (CRITICAL)

**Problem:** Interfaces defined by providers, not consumers

```go
// âŒ WRONG: Provider defines interface
// internal/generator/validator.go
type Validator interface { ... }

// âŒ WRONG: CLI imports generator to use interface
// internal/cli/commands/new.go (future)
import "github.com/anomalousventures/tracks/internal/generator"
```

**Fix:** Consumer defines interface

```go
// âœ… CORRECT: Consumer defines interface
// internal/cli/interfaces/validator.go
type Validator interface { ... }

// âœ… CORRECT: Generator implements consumer's interface
// internal/generator/validator_impl.go
type validatorImpl struct { ... }
func (v *validatorImpl) ValidateProjectName(...) { ... }
```

### 3. Validator Import Cycle (CRITICAL)

**Current:**

```text
internal/generator/validator_impl.go imports internal/cli (for logger)
internal/cli will import internal/generator (for Validator interface - Phase 3)
= IMPORT CYCLE (will break in Phase 3)
```

**Fix:** Pass logger as dependency, don't import cli package

### 4. No Dependency Injection Pattern (CRITICAL)

**Current:**

```go
// âŒ Direct instantiation, untestable
func newCmd() *cobra.Command {
    return &cobra.Command{
        Run: func(cmd *cobra.Command, args []string) {
            validator := generator.NewValidator()  // Hard-coded dependency
            // Can't mock, can't test
        },
    }
}
```

**Fix:**

```go
// âœ… Dependency injection, testable
type NewCommand struct {
    validator interfaces.Validator
    generator interfaces.ProjectGenerator
}

func NewNewCommand(v interfaces.Validator, g interfaces.ProjectGenerator) *NewCommand {
    return &NewCommand{validator: v, generator: g}
}
```

### 5. Command Structure Missing (CRITICAL)

**CLAUDE.md says:**
> **Key Files:**
>
> - `internal/cli/commands/` - Cobra command definitions

**Reality:**

- No `commands/` directory
- All commands inline in `root.go` (will become 1000+ lines)

**Fix:** Create command structure before Phase 3

## Scope

### In Scope

- Fix all 5 critical issues
- Establish dependency injection pattern
- Restructure packages for clarity
- Context propagation pattern
- Update all documentation
- Create architectural tests

### Out of Scope

- Feature work (Epic 3 Phase 3+ blocked until this completes)
- Minor refactoring (naming conventions, etc.)
- Generated server changes
- Performance optimization

## Task Breakdown

### Phase 1: Critical Fixes (Sequential - Must Complete First)

These tasks block all other work. Must be completed in order.

1. **Create commands/ directory structure** (#153)
2. **Move newCmd to internal/cli/commands/new.go** (#154)
3. **Move versionCmd to internal/cli/commands/version.go** (#155)
4. **Create internal/cli/interfaces/ directory** (#156)
5. **Move Validator interface to internal/cli/interfaces/validator.go** (#157)
6. **Move ProjectGenerator interface to internal/cli/interfaces/generator.go** (#158)
7. **Fix validator â†’ cli import: pass logger as constructor param** (#159)
8. **Write unit tests for interface moves** (#160)

### Phase 2: Dependency Injection Pattern (Can Start After Phase 1)

Establish the pattern we'll use throughout.

1. **Create NewCommand struct with DI fields** (#161)
2. **Implement NewNewCommand constructor** (#162)
3. **Create VersionCommand struct with DI** (#163)
4. **Update root.go to use command factories** (#164)
5. **Write unit tests for NewCommand** (#165)
6. **Write unit tests for VersionCommand** (#166)

### Phase 3: Package Restructuring (Can Parallelize with Phase 2)

Clean separation of concerns.

1. **Create internal/validation/ package** (#167)
2. **Move validator implementation to internal/validation/** (#168)
3. **Update imports across codebase** (#169)
4. **Write tests for validation package** (#170)

### Phase 4: Context Propagation (After Phase 2)

Consistent pattern for request-scoped values.

1. **Establish context propagation pattern** (#171)
2. **Attach logger to context in root** (#172)
3. **Update command signatures to receive context** (#173)
4. **Write tests for context propagation** (#174)

### Phase 5: Documentation Updates (After Phase 4)

Make documentation match reality.

1. **Update CLAUDE.md CLI architecture section** (#175)
2. **Update Epic 3 to reflect new structure** (#176)
3. **Update Epic 1 (completed work) for accuracy** (#177)
4. **Create architecture decision records** (#178)

### Phase 6: Architecture Tests (After Phase 5)

Prevent regression.

1. **Add import cycle detection test** (#179)
2. **Add interface location validation test** (#180)
3. **Add DI pattern enforcement test** (#181)
4. **Document architecture test strategy** (#182)

## Dependencies

### Prerequisites

- Epic 1 (CLI Infrastructure) - Complete âœ…
- Epic 2 (Template Engine) - Complete âœ…
- Epic 3 Phase 1 (Interfaces & Types) - Complete âœ…
- Epic 3 Phase 2 (Validation Logic) - Complete âœ…

### Blocks

- **Epic 3 Phase 3** (Command Implementation) - BLOCKED until Epic 0.5 complete
- **Epic 3 Phase 4+** (File Generation) - BLOCKED
- All future CLI work

## Acceptance Criteria

### Structural

- [ ] `internal/cli/commands/` directory exists
- [ ] `internal/cli/interfaces/` directory exists
- [ ] `internal/validation/` package exists
- [ ] All interfaces in consumer packages
- [ ] All commands use DI pattern
- [ ] No import cycles detected

### Testing

- [ ] `make lint` passes
- [ ] `make test` passes
- [ ] All new code has >90% test coverage
- [ ] Architecture tests enforce patterns

### Documentation

- [ ] CLAUDE.md CLI section accurate
- [ ] Epic 3 updated with new structure
- [ ] All code examples show DI pattern
- [ ] Architecture Decision Records created

### Quality

- [ ] Zero `go vet` warnings
- [ ] Zero `golangci-lint` errors
- [ ] All commands testable in isolation
- [ ] Context propagated consistently

## Technical Notes

### New Directory Structure

```text
internal/
â”œâ”€â”€ cli/
â”‚   â”œâ”€â”€ commands/
â”‚   â”‚   â”œâ”€â”€ new.go           # NewCommand struct + constructor
â”‚   â”‚   â””â”€â”€ version.go       # VersionCommand struct + constructor
â”‚   â”œâ”€â”€ interfaces/
â”‚   â”‚   â”œâ”€â”€ generator.go     # ProjectGenerator interface
â”‚   â”‚   â””â”€â”€ validator.go     # Validator interface
â”‚   â”œâ”€â”€ renderer/            # Existing
â”‚   â”œâ”€â”€ ui/                  # Existing
â”‚   â”œâ”€â”€ logger.go            # Existing
â”‚   â””â”€â”€ root.go              # Simplified (just setup + factories)
â”œâ”€â”€ generator/
â”‚   â”œâ”€â”€ generator.go         # Generator interface (will move to cli/interfaces)
â”‚   â”œâ”€â”€ generator_impl.go    # Implementation (future)
â”‚   â”œâ”€â”€ config.go            # Existing
â”‚   â”œâ”€â”€ errors.go            # Existing
â”‚   â””â”€â”€ template/            # Existing
â””â”€â”€ validation/
    â”œâ”€â”€ validator.go         # Validator implementation (moved from generator/)
    â””â”€â”€ rules.go             # Validation rules (extracted)
```

### Dependency Injection Pattern

**Command Structure:**

```go
// internal/cli/commands/new.go
package commands

import (
    "context"
    "github.com/anomalousventures/tracks/internal/cli/interfaces"
    "github.com/spf13/cobra"
)

type NewCommand struct {
    validator interfaces.Validator
    generator interfaces.ProjectGenerator
}

func NewNewCommand(v interfaces.Validator, g interfaces.ProjectGenerator) *NewCommand {
    return &NewCommand{
        validator: v,
        generator: g,
    }
}

func (c *NewCommand) Command() *cobra.Command {
    return &cobra.Command{
        Use:   "new [project-name]",
        Short: "Create a new Tracks application",
        Args:  cobra.ExactArgs(1),
        RunE:  c.run,
    }
}

func (c *NewCommand) run(cmd *cobra.Command, args []string) error {
    ctx := cmd.Context()
    projectName := args[0]

    // Use injected dependencies
    if err := c.validator.ValidateProjectName(projectName); err != nil {
        return err
    }

    // ... rest of implementation
    return nil
}
```

**Root Setup:**

```go
// internal/cli/root.go
func NewRootCmd(build BuildInfo) *cobra.Command {
    // ... root cmd setup

    // Wire up dependencies
    logger := NewLogger("off")
    validator := validation.NewValidator(logger)  // Pass logger explicitly
    generator := generator.NewGenerator()

    // Create commands with DI
    newCommand := commands.NewNewCommand(validator, generator)
    versionCommand := commands.NewVersionCommand(build)

    // Add subcommands
    rootCmd.AddCommand(newCommand.Command())
    rootCmd.AddCommand(versionCommand.Command())

    return rootCmd
}
```

### Interface Placement Rules

**Rule 1:** Interfaces belong in the package that uses them (consumer)

```go
// âœ… CORRECT
internal/cli/interfaces/validator.go  // CLI uses validator, owns interface
internal/validation/validator.go      // Implementation

// âŒ WRONG
internal/validation/validator.go      // Both interface and impl together
```

**Rule 2:** Avoid `interfaces` package if only one consumer

```go
// âœ… BETTER (if only NewCommand uses Validator)
internal/cli/commands/interfaces.go   // In commands package

// âš ï¸ ACCEPTABLE (if multiple commands use it)
internal/cli/interfaces/validator.go  // Shared interfaces
```

**Rule 3:** Use descriptive names (not just "Interface")

```go
// âœ… GOOD
type Validator interface { ... }
type ProjectGenerator interface { ... }

// âŒ BAD
type ValidatorInterface interface { ... }
type IValidator interface { ... }
```

### Context Propagation

**Pattern:**

```go
// Attach logger in root
ctx := context.Background()
ctx = WithLogger(ctx, logger)
cmd.SetContext(ctx)

// Retrieve in command
func (c *NewCommand) run(cmd *cobra.Command, args []string) error {
    logger := GetLogger(cmd.Context())
    logger.Debug().Str("project", args[0]).Msg("creating project")
    // ...
}
```

**Rules:**

- Always pass `context.Context` as first parameter
- Never store context in struct fields
- Attach request-scoped values only (logger, tracing, etc.)

### Validation Package

**Responsibility:** Validate inputs (project names, paths, drivers)

**Does NOT:**

- Generate projects (that's generator package)
- Render templates (that's generator/template)
- Parse CLI flags (that's commands package)

**Clean separation:**

```go
// internal/validation/validator.go
package validation

import "github.com/rs/zerolog"

type Validator struct {
    logger zerolog.Logger  // Passed via constructor, not imported
}

func NewValidator(logger zerolog.Logger) *Validator {
    return &Validator{logger: logger}
}

func (v *Validator) ValidateProjectName(name string) error {
    // Validation logic
    if err != nil {
        v.logger.Warn().Str("name", name).Msg("invalid project name")
        return err
    }
    return nil
}
```

## Testing Strategy

### Unit Tests

Every new file must have corresponding `_test.go`:

- `internal/cli/commands/new_test.go` - Test NewCommand with mocks
- `internal/cli/commands/version_test.go` - Test VersionCommand
- `internal/validation/validator_test.go` - Test validation logic
- `internal/cli/interfaces/` - No tests (just interfaces)

### Architecture Tests

Enforce patterns programmatically:

```go
// internal/cli/commands/architecture_test.go
func TestNoImportCycles(t *testing.T) {
    // Use golang.org/x/tools/go/packages to detect cycles
}

func TestInterfacesInConsumerPackages(t *testing.T) {
    // Verify cli/interfaces only contains interfaces
    // Verify no interfaces in provider packages
}

func TestCommandsUseDI(t *testing.T) {
    // Verify all Command structs have constructor functions
    // Verify no direct instantiation in Run methods
}
```

### Integration Tests

After Epic 0.5 complete, verify:

- `tracks version` still works
- `tracks new myapp` stub still works
- All flags work (--json, --no-color, etc.)

## Migration Path

### For Each Command

1. Create `internal/cli/commands/<command>.go`
2. Define `<Command>Command struct`
3. Add constructor `New<Command>Command(...)`
4. Implement `Command() *cobra.Command`
5. Move logic to `run(cmd, args) error`
6. Write tests with mocked dependencies
7. Update `root.go` to use factory

### For Each Interface

1. Identify consumers (who uses this?)
2. Create interface in consumer package
3. Update provider to implement interface
4. Update imports
5. Remove old interface definition
6. Run tests

## Rollout Plan

### Phase 1: Day 1 Morning (4 hours)

- Create directory structure
- Move commands to separate files
- Move interfaces to cli package
- Fix validator import cycle

**Checkpoint:** No import cycles, structure in place

### Phase 2: Day 1 Afternoon (3 hours)

- Establish DI pattern
- Refactor NewCommand
- Refactor VersionCommand
- Update root.go

**Checkpoint:** Commands use DI, tests pass

### Phase 3: Day 2 Morning (3 hours)

- Create validation package
- Move validator implementation
- Update imports
- Fix tests

**Checkpoint:** Clean package separation

### Phase 4: Day 2 Afternoon (2 hours)

- Context propagation
- Documentation updates
- Architecture tests

**Checkpoint:** Epic 0.5 complete, ready for Epic 3 Phase 3

## Success Metrics

- **Architectural:** Zero import cycles, all interfaces in consumer packages
- **Testing:** 100% of new code has tests, architecture tests prevent regression
- **Documentation:** CLAUDE.md accurate, Epic 3 updated, ADRs created
- **Velocity:** Epic 3 Phase 3 can start immediately after completion

## Risks & Mitigation

### Risk: Breaking Existing Functionality

**Mitigation:**

- Keep integration tests green throughout
- Make small, incremental changes
- Test after each phase

### Risk: Delays Epic 3 Delivery

**Mitigation:**

- This IS Epic 3 work (preventing future rework)
- 2 days now vs 5+ days later
- Faster Epic 3 Phase 3+ after this complete

### Risk: Incomplete Architecture

**Mitigation:**

- Architecture tests enforce patterns
- Code reviews focus on architecture
- ADRs document decisions

## Next Epic

After Epic 0.5 complete:

[Epic 3 Phase 3: Command Implementation â†’](./3-project-generation.md#phase-3-command-implementation)

---

**Status:** ğŸ”´ NOT STARTED (Blocking Epic 3 Phase 3)

**Estimated Completion:** 2 days (16 hours)

**Priority:** ğŸš¨ CRITICAL - Stop all other work
