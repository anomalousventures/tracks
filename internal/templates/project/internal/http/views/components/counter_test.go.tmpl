package components

import (
	"bytes"
	"context"
	"testing"

	"github.com/PuerkitoBio/goquery"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"{{.ModuleName}}/internal/http/routes"
)

func TestCounterDisplay(t *testing.T) {
	tests := []struct {
		name       string
		count      int
		wantCount  string
		assertions func(t *testing.T, doc *goquery.Document)
	}{
		{
			name:      "should render counter with zero count",
			count:     0,
			wantCount: "0",
			assertions: func(t *testing.T, doc *goquery.Document) {
				container := doc.Find("#counter-display")
				assert.Equal(t, 1, container.Length(), "should have counter-display container")

				countText := doc.Find("#counter-display p strong").Text()
				assert.Equal(t, "0", countText, "should display count of 0")

				incrementBtn := doc.Find("button").FilterFunction(func(i int, s *goquery.Selection) bool {
					return s.Text() == "Increment"
				})
				assert.Equal(t, 1, incrementBtn.Length(), "should have increment button")

				hxPost, exists := incrementBtn.Attr("hx-post")
				assert.True(t, exists, "increment button should have hx-post attribute")
				assert.Equal(t, routes.CounterIncrement, hxPost, "increment button should post to correct endpoint")

				hxTarget, exists := incrementBtn.Attr("hx-target")
				assert.True(t, exists, "increment button should have hx-target attribute")
				assert.Equal(t, "#counter-display", hxTarget, "increment button should target counter-display")

				hxSwap, exists := incrementBtn.Attr("hx-swap")
				assert.True(t, exists, "increment button should have hx-swap attribute")
				assert.Equal(t, "outerHTML transition:false", hxSwap, "increment button should use outerHTML swap without transition")

				decrementBtn := doc.Find("button").FilterFunction(func(i int, s *goquery.Selection) bool {
					return s.Text() == "Decrement"
				})
				assert.Equal(t, 1, decrementBtn.Length(), "should have decrement button")

				hxPost, exists = decrementBtn.Attr("hx-post")
				assert.True(t, exists, "decrement button should have hx-post attribute")
				assert.Equal(t, routes.CounterDecrement, hxPost, "decrement button should post to correct endpoint")

				resetBtn := doc.Find("button").FilterFunction(func(i int, s *goquery.Selection) bool {
					return s.Text() == "Reset"
				})
				assert.Equal(t, 1, resetBtn.Length(), "should have reset button")

				hxPost, exists = resetBtn.Attr("hx-post")
				assert.True(t, exists, "reset button should have hx-post attribute")
				assert.Equal(t, routes.CounterReset, hxPost, "reset button should post to correct endpoint")
			},
		},
		{
			name:      "should render counter with positive count",
			count:     42,
			wantCount: "42",
			assertions: func(t *testing.T, doc *goquery.Document) {
				countText := doc.Find("#counter-display p strong").Text()
				assert.Equal(t, "42", countText, "should display count of 42")

				buttons := doc.Find("button")
				assert.Equal(t, 3, buttons.Length(), "should have 3 buttons (increment, decrement, reset)")
			},
		},
		{
			name:      "should render counter with negative count",
			count:     -10,
			wantCount: "-10",
			assertions: func(t *testing.T, doc *goquery.Document) {
				countText := doc.Find("#counter-display p strong").Text()
				assert.Equal(t, "-10", countText, "should display count of -10")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			err := CounterDisplay(tt.count).Render(context.Background(), &buf)
			require.NoError(t, err, "component should render without error")

			doc, err := goquery.NewDocumentFromReader(&buf)
			require.NoError(t, err, "should parse rendered HTML")

			if tt.assertions != nil {
				tt.assertions(t, doc)
			}
		})
	}
}

func TestNotificationOOB(t *testing.T) {
	tests := []struct {
		name        string
		message     string
		messageType string
		assertions  func(t *testing.T, doc *goquery.Document)
	}{
		{
			name:        "should render success notification with OOB swap",
			message:     "Counter incremented!",
			messageType: "success",
			assertions: func(t *testing.T, doc *goquery.Document) {
				notification := doc.Find("#notification-area")
				assert.Equal(t, 1, notification.Length(), "should have notification area")

				hxSwapOob, exists := notification.Attr("hx-swap-oob")
				assert.True(t, exists, "notification should have hx-swap-oob attribute")
				assert.Equal(t, "true", hxSwapOob, "hx-swap-oob should be true")

				assert.True(t, notification.HasClass("notification"), "should have notification class")
				assert.True(t, notification.HasClass("success"), "should have success class")

				message := notification.Find("p").Text()
				assert.Equal(t, "Counter incremented!", message, "should display correct message")
			},
		},
		{
			name:        "should render error notification with OOB swap",
			message:     "An error occurred",
			messageType: "error",
			assertions: func(t *testing.T, doc *goquery.Document) {
				notification := doc.Find("#notification-area")
				assert.Equal(t, 1, notification.Length(), "should have notification area")

				assert.True(t, notification.HasClass("error"), "should have error class")

				message := notification.Find("p").Text()
				assert.Equal(t, "An error occurred", message, "should display correct message")
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			err := NotificationOOB(tt.message, tt.messageType).Render(context.Background(), &buf)
			require.NoError(t, err, "component should render without error")

			doc, err := goquery.NewDocumentFromReader(&buf)
			require.NoError(t, err, "should parse rendered HTML")

			if tt.assertions != nil {
				tt.assertions(t, doc)
			}
		})
	}
}

func TestCounter_HTMXAttributeValidation(t *testing.T) {
	count := 0
	var buf bytes.Buffer
	err := CounterDisplay(count).Render(context.Background(), &buf)
	require.NoError(t, err, "component should render without error")

	doc, err := goquery.NewDocumentFromReader(&buf)
	require.NoError(t, err, "should parse rendered HTML")

	expectedButtons := []struct {
		text     string
		hxPost   string
		hxTarget string
		hxSwap   string
	}{
		{"Increment", routes.CounterIncrement, "#counter-display", "outerHTML transition:false"},
		{"Decrement", routes.CounterDecrement, "#counter-display", "outerHTML transition:false"},
		{"Reset", routes.CounterReset, "#counter-display", "outerHTML transition:false"},
	}

	for _, expected := range expectedButtons {
		t.Run("validate HTMX attributes for "+expected.text+" button", func(t *testing.T) {
			button := doc.Find("button").FilterFunction(func(i int, s *goquery.Selection) bool {
				return s.Text() == expected.text
			})

			require.Equal(t, 1, button.Length(), "should find %s button", expected.text)

			hxPost, exists := button.Attr("hx-post")
			assert.True(t, exists, "%s button must have hx-post attribute", expected.text)
			assert.Equal(t, expected.hxPost, hxPost, "%s button hx-post should match", expected.text)

			hxTarget, exists := button.Attr("hx-target")
			assert.True(t, exists, "%s button must have hx-target attribute", expected.text)
			assert.Equal(t, expected.hxTarget, hxTarget, "%s button hx-target should match", expected.text)

			hxSwap, exists := button.Attr("hx-swap")
			assert.True(t, exists, "%s button must have hx-swap attribute", expected.text)
			assert.Equal(t, expected.hxSwap, hxSwap, "%s button hx-swap should match", expected.text)
		})
	}
}
