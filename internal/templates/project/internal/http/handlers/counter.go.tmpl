package handlers

import (
	"net/http"
	"sync/atomic"

	"{{.ModuleName}}/internal/http/views/components"
	"{{.ModuleName}}/internal/interfaces"
)

type CounterHandler struct {
	logger interfaces.Logger
	count  atomic.Int64
}

func NewCounterHandler(logger interfaces.Logger) *CounterHandler {
	return &CounterHandler{
		logger: logger,
	}
}

func (h *CounterHandler) GetCount() int {
	return int(h.count.Load())
}

func (h *CounterHandler) Increment(w http.ResponseWriter, r *http.Request) {
	count := int(h.count.Add(1))
	h.renderPartial(w, r, count)
}

func (h *CounterHandler) Decrement(w http.ResponseWriter, r *http.Request) {
	count := int(h.count.Add(-1))
	h.renderPartial(w, r, count)
}

func (h *CounterHandler) Reset(w http.ResponseWriter, r *http.Request) {
	h.count.Store(0)
	ctx := r.Context()

	w.Header().Set("Content-Type", "text/html; charset=utf-8")

	if err := components.CounterDisplay(0).Render(ctx, w); err != nil {
		h.logger.Error(ctx).Err(err).Msg("failed to render counter display")
		http.Error(w, "Failed to render counter", http.StatusInternalServerError)
		return
	}

	if err := components.NotificationOOB("Counter reset to 0", "success").Render(ctx, w); err != nil {
		h.logger.Error(ctx).Err(err).Msg("failed to render notification")
	}
}

func (h *CounterHandler) renderPartial(w http.ResponseWriter, r *http.Request, count int) {
	ctx := r.Context()
	w.Header().Set("Content-Type", "text/html; charset=utf-8")

	if err := components.CounterDisplay(count).Render(ctx, w); err != nil {
		h.logger.Error(ctx).Err(err).Msg("failed to render counter display")
		http.Error(w, "Failed to render counter", http.StatusInternalServerError)
	}
}
